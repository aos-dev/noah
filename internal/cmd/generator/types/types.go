// The following directive is necessary to make the package coherent:
// This program generates types, It can be invoked by running
// go generate
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"
)

func main() {
	const filePath = "types.go"

	data, err := ioutil.ReadFile("types.json")
	if err != nil {
		log.Fatal(err)
	}
	types := make(map[string]string)
	err = json.Unmarshal(data, &types)
	if err != nil {
		log.Fatal(err)
	}

	// Format input tasks.json
	data, err = json.MarshalIndent(types, "", "  ")
	if err != nil {
		log.Fatal(err)
	}
	err = ioutil.WriteFile("types.json", data, 0664)
	if err != nil {
		log.Fatal(err)
	}

	f, err := os.Create(filePath)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	err = tmpl.Execute(f, struct {
		Data map[string]string
	}{
		types,
	})
	if err != nil {
		log.Fatal(err)
	}
}

var funcs = template.FuncMap{
	"stringType": func(k, v string) string {
		f, ok := stringMap[k]
		if !ok {
			return `return ""`
		}
		if strings.HasPrefix(k, "*") {
			return f(v)
		}
		return "return " + f(v)
	},
}

var stringMap = map[string]func(s string) string{
	"string": func(s string) string {
		return s
	},
	"bool": func(s string) string {
		return fmt.Sprintf("strconv.FormatBool(%s)", s)
	},
	"*types.Object": func(s string) string {
		return fmt.Sprintf(
			`if %s == nil {
	return ""
}
return fmt.Sprint(%s)`, s, s)
	},
	"types.IndexSegmenter": func(s string) string {
		return fmt.Sprintf("%s.(types.Storager).String()", s)
	},
	"types.Servicer": func(s string) string {
		return fmt.Sprintf("%s.String()", s)
	},
	"types.Storager": func(s string) string {
		return fmt.Sprintf("%s.String()", s)
	},
	"types.ObjectType": func(s string) string {
		return fmt.Sprintf("string(%s)", s)
	},
	"types.DirLister": func(s string) string {
		return fmt.Sprintf("%s.(types.Storager).String()", s)
	},
	"*regexp.Regexp": func(s string) string {
		return fmt.Sprintf(
			`if %s == nil {
	return ""
}
return %s.String()`, s, s)
	},
	"int64": func(s string) string {
		return fmt.Sprintf("strconv.FormatInt(%s, 10)", s)
	},
	"int": func(s string) string {
		return fmt.Sprintf("strconv.Itoa(%s)", s)
	},
}

var tmpl = template.Must(template.New("").Funcs(funcs).Parse(`// Code generated by go generate; DO NOT EDIT.
package types

import (
	"bytes"
	"fmt"
	"io"
	"regexp"
	"strconv"
	"sync"

	"github.com/aos-dev/go-storage/v2/types"

	"github.com/aos-dev/noah/pkg/schedule"
	"github.com/aos-dev/noah/pkg/task"
)

var _ fmt.Stringer

{{- range $k, $v := .Data }}
type {{$k}} struct {
	valid bool
	v {{$v}}

	l sync.RWMutex
}

type {{$k}}Getter interface {
	Get{{$k}}() {{$v}}
}

func (o *{{$k}}) Get{{$k}}() {{$v}} {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("{{$k}} value is not valid")
	}
	return o.v
}

type {{$k}}Setter interface {
	Set{{$k}}({{$v}})
}

func (o *{{$k}}) Set{{$k}}(v {{$v}}) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type {{$k}}Validator interface {
	Validate{{$k}}() bool
}

func (o *{{$k}}) Validate{{$k}}() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func Load{{$k}}(t task.Task, v {{$k}}Setter) {
	x, ok := t.(interface{
		{{$k}}Getter
		{{$k}}Validator
	})
	if !ok {
		return
	}
	if !x.Validate{{$k}}() {
		return
	}

	v.Set{{$k}}(x.Get{{$k}}())
}

func (o *{{$k}}) String() string {
	if !o.valid {
		return ""
	}
	{{stringType $v "o.v"}}
}
{{- end }}

`))
