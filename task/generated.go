// Code generated by go generate; DO NOT EDIT.
package task

import (
	"context"
	"fmt"
	"strings"

	"github.com/google/uuid"
	"github.com/qingstor/log"

	"github.com/aos-dev/noah/pkg/schedule"
	"github.com/aos-dev/noah/pkg/task"
	"github.com/aos-dev/noah/pkg/types"
)

var _ = uuid.New()

// BetweenStorageCheckTask will Do check for between storage task.
type BetweenStorageCheckTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Optional Input value

	// Output value
	types.DestinationObject
	types.SourceObject
}

// NewBetweenStorageCheck will create a BetweenStorageCheckTask struct and fetch inherited data from parent task.
func NewBetweenStorageCheck(task task.Task) *BetweenStorageCheckTask {
	t := &BetweenStorageCheckTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *BetweenStorageCheckTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task BetweenStorageCheck value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task BetweenStorageCheck value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task BetweenStorageCheck value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task BetweenStorageCheck value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *BetweenStorageCheckTask) loadInput(task task.Task) {
	// load required fields
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	// load optional fields
}

// Sync run sub task directly
func (t *BetweenStorageCheckTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *BetweenStorageCheckTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *BetweenStorageCheckTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *BetweenStorageCheckTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "BetweenStorageCheckTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *BetweenStorageCheckTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *BetweenStorageCheckTask) String() string {
	s := make([]string, 0, 4)

	s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	return fmt.Sprintf("BetweenStorageCheckTask {%s}", strings.Join(s, ", "))
}

// NewBetweenStorageCheckTask will create a BetweenStorageCheckTask which meets task.Task.
func NewBetweenStorageCheckTask(task task.Task) task.Task {
	return NewBetweenStorageCheck(task)
}

// CopyDirTask will copy a directory recursively between two storager.
type CopyDirTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Optional Input value
	types.CheckMD5
	types.CheckTasks
	types.HandleObjCallbackFunc
	types.PartSize
	types.PartThreshold
	types.StorageClass

	// Output value
}

// NewCopyDir will create a CopyDirTask struct and fetch inherited data from parent task.
func NewCopyDir(task task.Task) *CopyDirTask {
	t := &CopyDirTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyDirTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyDir value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyDir value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyDir value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyDir value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyDirTask) loadInput(task task.Task) {
	// load required fields
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	// load optional fields
	types.LoadCheckMD5(task, t)
	types.LoadCheckTasks(task, t)
	types.LoadHandleObjCallbackFunc(task, t)
	types.LoadPartSize(task, t)
	types.LoadPartThreshold(task, t)
	types.LoadStorageClass(task, t)
}

// Sync run sub task directly
func (t *CopyDirTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *CopyDirTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *CopyDirTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *CopyDirTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "CopyDirTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyDirTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyDirTask) String() string {
	s := make([]string, 0, 10)

	s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidateCheckTasks() {
		s = append(s, fmt.Sprintf("CheckTasks: %s", t.CheckTasks.String()))
	}
	if t.ValidatePartSize() {
		s = append(s, fmt.Sprintf("PartSize: %s", t.PartSize.String()))
	}
	if t.ValidatePartThreshold() {
		s = append(s, fmt.Sprintf("PartThreshold: %s", t.PartThreshold.String()))
	}
	if t.ValidateStorageClass() {
		s = append(s, fmt.Sprintf("StorageClass: %s", t.StorageClass.String()))
	}
	return fmt.Sprintf("CopyDirTask {%s}", strings.Join(s, ", "))
}

// NewCopyDirTask will create a CopyDirTask which meets task.Task.
func NewCopyDirTask(task task.Task) task.Task {
	return NewCopyDir(task)
}

// CopyFileTask will copy a file between two storager.
type CopyFileTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Optional Input value
	types.CheckMD5
	types.CheckTasks
	types.DryRunFunc
	types.HandleObjCallbackFunc
	types.PartSize
	types.PartThreshold
	types.StorageClass

	// Output value
}

// NewCopyFile will create a CopyFileTask struct and fetch inherited data from parent task.
func NewCopyFile(task task.Task) *CopyFileTask {
	t := &CopyFileTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyFileTask) loadInput(task task.Task) {
	// load required fields
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	// load optional fields
	types.LoadCheckMD5(task, t)
	types.LoadCheckTasks(task, t)
	types.LoadDryRunFunc(task, t)
	types.LoadHandleObjCallbackFunc(task, t)
	types.LoadPartSize(task, t)
	types.LoadPartThreshold(task, t)
	types.LoadStorageClass(task, t)
}

// Sync run sub task directly
func (t *CopyFileTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *CopyFileTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *CopyFileTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *CopyFileTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "CopyFileTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyFileTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyFileTask) String() string {
	s := make([]string, 0, 11)

	s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidateCheckTasks() {
		s = append(s, fmt.Sprintf("CheckTasks: %s", t.CheckTasks.String()))
	}
	if t.ValidatePartSize() {
		s = append(s, fmt.Sprintf("PartSize: %s", t.PartSize.String()))
	}
	if t.ValidatePartThreshold() {
		s = append(s, fmt.Sprintf("PartThreshold: %s", t.PartThreshold.String()))
	}
	if t.ValidateStorageClass() {
		s = append(s, fmt.Sprintf("StorageClass: %s", t.StorageClass.String()))
	}
	return fmt.Sprintf("CopyFileTask {%s}", strings.Join(s, ", "))
}

// NewCopyFileTask will create a CopyFileTask which meets task.Task.
func NewCopyFileTask(task task.Task) task.Task {
	return NewCopyFile(task)
}

// CopyLargeFileTask will copy a large file between two storager.
type CopyLargeFileTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage
	types.TotalSize

	// Optional Input value
	types.CheckMD5
	types.PartSize
	types.StorageClass

	// Output value
	types.Offset
	types.Segment
}

// NewCopyLargeFile will create a CopyLargeFileTask struct and fetch inherited data from parent task.
func NewCopyLargeFile(task task.Task) *CopyLargeFileTask {
	t := &CopyLargeFileTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyLargeFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyLargeFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyLargeFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyLargeFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyLargeFile value SourceStorage is invalid"))
	}
	if !t.ValidateTotalSize() {
		panic(fmt.Errorf("Task CopyLargeFile value TotalSize is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyLargeFileTask) loadInput(task task.Task) {
	// load required fields
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	types.LoadTotalSize(task, t)
	// load optional fields
	types.LoadCheckMD5(task, t)
	types.LoadPartSize(task, t)
	types.LoadStorageClass(task, t)
}

// Sync run sub task directly
func (t *CopyLargeFileTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *CopyLargeFileTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *CopyLargeFileTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *CopyLargeFileTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "CopyLargeFileTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyLargeFileTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyLargeFileTask) String() string {
	s := make([]string, 0, 8)

	s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	s = append(s, fmt.Sprintf("TotalSize: %s", t.TotalSize.String()))
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidatePartSize() {
		s = append(s, fmt.Sprintf("PartSize: %s", t.PartSize.String()))
	}
	if t.ValidateStorageClass() {
		s = append(s, fmt.Sprintf("StorageClass: %s", t.StorageClass.String()))
	}
	return fmt.Sprintf("CopyLargeFileTask {%s}", strings.Join(s, ", "))
}

// NewCopyLargeFileTask will create a CopyLargeFileTask which meets task.Task.
func NewCopyLargeFileTask(task task.Task) task.Task {
	return NewCopyLargeFile(task)
}

// CopyPartialFileTask will copy a partial file to between two storager.
type CopyPartialFileTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.DestinationPath
	types.DestinationStorage
	types.Index
	types.Offset
	types.PartSize
	types.Segment
	types.SourcePath
	types.SourceStorage
	types.TotalSize

	// Optional Input value
	types.CheckMD5
	types.StorageClass

	// Output value
	types.Done
	types.Size
}

// NewCopyPartialFile will create a CopyPartialFileTask struct and fetch inherited data from parent task.
func NewCopyPartialFile(task task.Task) *CopyPartialFileTask {
	t := &CopyPartialFileTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyPartialFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyPartialFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyPartialFile value DestinationStorage is invalid"))
	}
	if !t.ValidateIndex() {
		panic(fmt.Errorf("Task CopyPartialFile value Index is invalid"))
	}
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task CopyPartialFile value Offset is invalid"))
	}
	if !t.ValidatePartSize() {
		panic(fmt.Errorf("Task CopyPartialFile value PartSize is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task CopyPartialFile value Segment is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyPartialFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyPartialFile value SourceStorage is invalid"))
	}
	if !t.ValidateTotalSize() {
		panic(fmt.Errorf("Task CopyPartialFile value TotalSize is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyPartialFileTask) loadInput(task task.Task) {
	// load required fields
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadIndex(task, t)
	types.LoadOffset(task, t)
	types.LoadPartSize(task, t)
	types.LoadSegment(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	types.LoadTotalSize(task, t)
	// load optional fields
	types.LoadCheckMD5(task, t)
	types.LoadStorageClass(task, t)
}

// Sync run sub task directly
func (t *CopyPartialFileTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *CopyPartialFileTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *CopyPartialFileTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *CopyPartialFileTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "CopyPartialFileTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyPartialFileTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyPartialFileTask) String() string {
	s := make([]string, 0, 11)

	s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	s = append(s, fmt.Sprintf("Index: %s", t.Index.String()))
	s = append(s, fmt.Sprintf("Offset: %s", t.Offset.String()))
	s = append(s, fmt.Sprintf("PartSize: %s", t.PartSize.String()))
	s = append(s, fmt.Sprintf("Segment: %s", t.Segment.String()))
	s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	s = append(s, fmt.Sprintf("TotalSize: %s", t.TotalSize.String()))
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidateStorageClass() {
		s = append(s, fmt.Sprintf("StorageClass: %s", t.StorageClass.String()))
	}
	return fmt.Sprintf("CopyPartialFileTask {%s}", strings.Join(s, ", "))
}

// NewCopyPartialFileTask will create a CopyPartialFileTask which meets task.Task.
func NewCopyPartialFileTask(task task.Task) task.Task {
	return NewCopyPartialFile(task)
}

// CopyPartialStreamTask will copy a partial stream between two storager.
type CopyPartialStreamTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.DestinationPath
	types.DestinationStorage
	types.Index
	types.PartSize
	types.Segment
	types.SourcePath
	types.SourceStorage

	// Optional Input value
	types.CheckMD5
	types.StorageClass

	// Output value
	types.Content
	types.Done
	types.Offset
	types.Size
}

// NewCopyPartialStream will create a CopyPartialStreamTask struct and fetch inherited data from parent task.
func NewCopyPartialStream(task task.Task) *CopyPartialStreamTask {
	t := &CopyPartialStreamTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyPartialStreamTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyPartialStream value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyPartialStream value DestinationStorage is invalid"))
	}
	if !t.ValidateIndex() {
		panic(fmt.Errorf("Task CopyPartialStream value Index is invalid"))
	}
	if !t.ValidatePartSize() {
		panic(fmt.Errorf("Task CopyPartialStream value PartSize is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task CopyPartialStream value Segment is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyPartialStream value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyPartialStream value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyPartialStreamTask) loadInput(task task.Task) {
	// load required fields
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadIndex(task, t)
	types.LoadPartSize(task, t)
	types.LoadSegment(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	// load optional fields
	types.LoadCheckMD5(task, t)
	types.LoadStorageClass(task, t)
}

// Sync run sub task directly
func (t *CopyPartialStreamTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *CopyPartialStreamTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *CopyPartialStreamTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *CopyPartialStreamTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "CopyPartialStreamTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyPartialStreamTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyPartialStreamTask) String() string {
	s := make([]string, 0, 9)

	s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	s = append(s, fmt.Sprintf("Index: %s", t.Index.String()))
	s = append(s, fmt.Sprintf("PartSize: %s", t.PartSize.String()))
	s = append(s, fmt.Sprintf("Segment: %s", t.Segment.String()))
	s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidateStorageClass() {
		s = append(s, fmt.Sprintf("StorageClass: %s", t.StorageClass.String()))
	}
	return fmt.Sprintf("CopyPartialStreamTask {%s}", strings.Join(s, ", "))
}

// NewCopyPartialStreamTask will create a CopyPartialStreamTask which meets task.Task.
func NewCopyPartialStreamTask(task task.Task) task.Task {
	return NewCopyPartialStream(task)
}

// CopySingleFileTask will execute a file copy operation between two storager.
type CopySingleFileTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.DestinationPath
	types.DestinationStorage
	types.Size
	types.SourcePath
	types.SourceStorage

	// Optional Input value
	types.MD5Sum
	types.StorageClass

	// Output value
}

// NewCopySingleFile will create a CopySingleFileTask struct and fetch inherited data from parent task.
func NewCopySingleFile(task task.Task) *CopySingleFileTask {
	t := &CopySingleFileTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopySingleFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopySingleFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopySingleFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task CopySingleFile value Size is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopySingleFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopySingleFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopySingleFileTask) loadInput(task task.Task) {
	// load required fields
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSize(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	// load optional fields
	types.LoadMD5Sum(task, t)
	types.LoadStorageClass(task, t)
}

// Sync run sub task directly
func (t *CopySingleFileTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *CopySingleFileTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *CopySingleFileTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *CopySingleFileTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "CopySingleFileTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopySingleFileTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopySingleFileTask) String() string {
	s := make([]string, 0, 7)

	s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	s = append(s, fmt.Sprintf("Size: %s", t.Size.String()))
	s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	if t.ValidateMD5Sum() {
		s = append(s, fmt.Sprintf("MD5Sum: %s", t.MD5Sum.String()))
	}
	if t.ValidateStorageClass() {
		s = append(s, fmt.Sprintf("StorageClass: %s", t.StorageClass.String()))
	}
	return fmt.Sprintf("CopySingleFileTask {%s}", strings.Join(s, ", "))
}

// NewCopySingleFileTask will create a CopySingleFileTask which meets task.Task.
func NewCopySingleFileTask(task task.Task) task.Task {
	return NewCopySingleFile(task)
}

// CopySmallFileTask will copy a small file between two storager.
type CopySmallFileTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.DestinationPath
	types.DestinationStorage
	types.Size
	types.SourcePath
	types.SourceStorage

	// Optional Input value
	types.CheckMD5
	types.MD5Sum
	types.StorageClass

	// Output value
}

// NewCopySmallFile will create a CopySmallFileTask struct and fetch inherited data from parent task.
func NewCopySmallFile(task task.Task) *CopySmallFileTask {
	t := &CopySmallFileTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopySmallFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopySmallFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopySmallFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task CopySmallFile value Size is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopySmallFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopySmallFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopySmallFileTask) loadInput(task task.Task) {
	// load required fields
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSize(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	// load optional fields
	types.LoadCheckMD5(task, t)
	types.LoadMD5Sum(task, t)
	types.LoadStorageClass(task, t)
}

// Sync run sub task directly
func (t *CopySmallFileTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *CopySmallFileTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *CopySmallFileTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *CopySmallFileTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "CopySmallFileTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopySmallFileTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopySmallFileTask) String() string {
	s := make([]string, 0, 8)

	s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	s = append(s, fmt.Sprintf("Size: %s", t.Size.String()))
	s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidateMD5Sum() {
		s = append(s, fmt.Sprintf("MD5Sum: %s", t.MD5Sum.String()))
	}
	if t.ValidateStorageClass() {
		s = append(s, fmt.Sprintf("StorageClass: %s", t.StorageClass.String()))
	}
	return fmt.Sprintf("CopySmallFileTask {%s}", strings.Join(s, ", "))
}

// NewCopySmallFileTask will create a CopySmallFileTask which meets task.Task.
func NewCopySmallFileTask(task task.Task) task.Task {
	return NewCopySmallFile(task)
}

// CopyStreamTask will copy a stream between two storager.
type CopyStreamTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Optional Input value
	types.CheckMD5
	types.PartSize
	types.StorageClass

	// Output value
	types.BytesPool
	types.Segment
}

// NewCopyStream will create a CopyStreamTask struct and fetch inherited data from parent task.
func NewCopyStream(task task.Task) *CopyStreamTask {
	t := &CopyStreamTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyStreamTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyStream value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyStream value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyStream value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyStream value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyStreamTask) loadInput(task task.Task) {
	// load required fields
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	// load optional fields
	types.LoadCheckMD5(task, t)
	types.LoadPartSize(task, t)
	types.LoadStorageClass(task, t)
}

// Sync run sub task directly
func (t *CopyStreamTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *CopyStreamTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *CopyStreamTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *CopyStreamTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "CopyStreamTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyStreamTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyStreamTask) String() string {
	s := make([]string, 0, 7)

	s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidatePartSize() {
		s = append(s, fmt.Sprintf("PartSize: %s", t.PartSize.String()))
	}
	if t.ValidateStorageClass() {
		s = append(s, fmt.Sprintf("StorageClass: %s", t.StorageClass.String()))
	}
	return fmt.Sprintf("CopyStreamTask {%s}", strings.Join(s, ", "))
}

// NewCopyStreamTask will create a CopyStreamTask which meets task.Task.
func NewCopyStreamTask(task task.Task) task.Task {
	return NewCopyStream(task)
}

// CreateStorageTask will create a storage.
type CreateStorageTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Service

	// Optional Input value
	types.Zone

	// Output value
	types.StorageName
}

// NewCreateStorage will create a CreateStorageTask struct and fetch inherited data from parent task.
func NewCreateStorage(task task.Task) *CreateStorageTask {
	t := &CreateStorageTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CreateStorageTask) validateInput() {
	if !t.ValidateService() {
		panic(fmt.Errorf("Task CreateStorage value Service is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CreateStorageTask) loadInput(task task.Task) {
	// load required fields
	types.LoadService(task, t)
	// load optional fields
	types.LoadZone(task, t)
}

// Sync run sub task directly
func (t *CreateStorageTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *CreateStorageTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *CreateStorageTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *CreateStorageTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "CreateStorageTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *CreateStorageTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CreateStorageTask) String() string {
	s := make([]string, 0, 2)

	s = append(s, fmt.Sprintf("Service: %s", t.Service.String()))
	if t.ValidateZone() {
		s = append(s, fmt.Sprintf("Zone: %s", t.Zone.String()))
	}
	return fmt.Sprintf("CreateStorageTask {%s}", strings.Join(s, ", "))
}

// NewCreateStorageTask will create a CreateStorageTask which meets task.Task.
func NewCreateStorageTask(task task.Task) task.Task {
	return NewCreateStorage(task)
}

// DeleteDirTask will will delete a dir recursively.
type DeleteDirTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Path
	types.Storage

	// Optional Input value
	types.HandleObjCallbackFunc

	// Output value
}

// NewDeleteDir will create a DeleteDirTask struct and fetch inherited data from parent task.
func NewDeleteDir(task task.Task) *DeleteDirTask {
	t := &DeleteDirTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteDirTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task DeleteDir value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task DeleteDir value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteDirTask) loadInput(task task.Task) {
	// load required fields
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
	// load optional fields
	types.LoadHandleObjCallbackFunc(task, t)
}

// Sync run sub task directly
func (t *DeleteDirTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *DeleteDirTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *DeleteDirTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *DeleteDirTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "DeleteDirTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteDirTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeleteDirTask) String() string {
	s := make([]string, 0, 3)

	s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	s = append(s, fmt.Sprintf("Storage: %s", t.Storage.String()))
	return fmt.Sprintf("DeleteDirTask {%s}", strings.Join(s, ", "))
}

// NewDeleteDirTask will create a DeleteDirTask which meets task.Task.
func NewDeleteDirTask(task task.Task) task.Task {
	return NewDeleteDir(task)
}

// DeleteFileTask will will delete a file from storage.
type DeleteFileTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Path
	types.Storage

	// Optional Input value
	types.HandleObjCallbackFunc

	// Output value
}

// NewDeleteFile will create a DeleteFileTask struct and fetch inherited data from parent task.
func NewDeleteFile(task task.Task) *DeleteFileTask {
	t := &DeleteFileTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteFileTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task DeleteFile value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task DeleteFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteFileTask) loadInput(task task.Task) {
	// load required fields
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
	// load optional fields
	types.LoadHandleObjCallbackFunc(task, t)
}

// Sync run sub task directly
func (t *DeleteFileTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *DeleteFileTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *DeleteFileTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *DeleteFileTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "DeleteFileTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteFileTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeleteFileTask) String() string {
	s := make([]string, 0, 3)

	s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	s = append(s, fmt.Sprintf("Storage: %s", t.Storage.String()))
	return fmt.Sprintf("DeleteFileTask {%s}", strings.Join(s, ", "))
}

// NewDeleteFileTask will create a DeleteFileTask which meets task.Task.
func NewDeleteFileTask(task task.Task) task.Task {
	return NewDeleteFile(task)
}

// DeletePrefixTask will will delete objects with given prefix from storage.
type DeletePrefixTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Path
	types.Storage

	// Optional Input value
	types.HandleObjCallbackFunc

	// Output value
}

// NewDeletePrefix will create a DeletePrefixTask struct and fetch inherited data from parent task.
func NewDeletePrefix(task task.Task) *DeletePrefixTask {
	t := &DeletePrefixTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeletePrefixTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task DeletePrefix value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task DeletePrefix value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeletePrefixTask) loadInput(task task.Task) {
	// load required fields
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
	// load optional fields
	types.LoadHandleObjCallbackFunc(task, t)
}

// Sync run sub task directly
func (t *DeletePrefixTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *DeletePrefixTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *DeletePrefixTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *DeletePrefixTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "DeletePrefixTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeletePrefixTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeletePrefixTask) String() string {
	s := make([]string, 0, 3)

	s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	s = append(s, fmt.Sprintf("Storage: %s", t.Storage.String()))
	return fmt.Sprintf("DeletePrefixTask {%s}", strings.Join(s, ", "))
}

// NewDeletePrefixTask will create a DeletePrefixTask which meets task.Task.
func NewDeletePrefixTask(task task.Task) task.Task {
	return NewDeletePrefix(task)
}

// DeleteSegmentTask will delete segments with a given path.
type DeleteSegmentTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.PrefixSegmentsLister
	types.Segment

	// Optional Input value
	types.HandleSegmentCallbackFunc

	// Output value
}

// NewDeleteSegment will create a DeleteSegmentTask struct and fetch inherited data from parent task.
func NewDeleteSegment(task task.Task) *DeleteSegmentTask {
	t := &DeleteSegmentTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteSegmentTask) validateInput() {
	if !t.ValidatePrefixSegmentsLister() {
		panic(fmt.Errorf("Task DeleteSegment value PrefixSegmentsLister is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task DeleteSegment value Segment is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteSegmentTask) loadInput(task task.Task) {
	// load required fields
	types.LoadPrefixSegmentsLister(task, t)
	types.LoadSegment(task, t)
	// load optional fields
	types.LoadHandleSegmentCallbackFunc(task, t)
}

// Sync run sub task directly
func (t *DeleteSegmentTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *DeleteSegmentTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *DeleteSegmentTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *DeleteSegmentTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "DeleteSegmentTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteSegmentTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeleteSegmentTask) String() string {
	s := make([]string, 0, 3)

	s = append(s, fmt.Sprintf("PrefixSegmentsLister: %s", t.PrefixSegmentsLister.String()))
	s = append(s, fmt.Sprintf("Segment: %s", t.Segment.String()))
	return fmt.Sprintf("DeleteSegmentTask {%s}", strings.Join(s, ", "))
}

// NewDeleteSegmentTask will create a DeleteSegmentTask which meets task.Task.
func NewDeleteSegmentTask(task task.Task) task.Task {
	return NewDeleteSegment(task)
}

// DeleteSegmentsByPrefixTask will delete all segments with a given path.
type DeleteSegmentsByPrefixTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Prefix
	types.PrefixSegmentsLister

	// Optional Input value
	types.HandleSegmentCallbackFunc

	// Output value
}

// NewDeleteSegmentsByPrefix will create a DeleteSegmentsByPrefixTask struct and fetch inherited data from parent task.
func NewDeleteSegmentsByPrefix(task task.Task) *DeleteSegmentsByPrefixTask {
	t := &DeleteSegmentsByPrefixTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteSegmentsByPrefixTask) validateInput() {
	if !t.ValidatePrefix() {
		panic(fmt.Errorf("Task DeleteSegmentsByPrefix value Prefix is invalid"))
	}
	if !t.ValidatePrefixSegmentsLister() {
		panic(fmt.Errorf("Task DeleteSegmentsByPrefix value PrefixSegmentsLister is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteSegmentsByPrefixTask) loadInput(task task.Task) {
	// load required fields
	types.LoadPrefix(task, t)
	types.LoadPrefixSegmentsLister(task, t)
	// load optional fields
	types.LoadHandleSegmentCallbackFunc(task, t)
}

// Sync run sub task directly
func (t *DeleteSegmentsByPrefixTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *DeleteSegmentsByPrefixTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *DeleteSegmentsByPrefixTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *DeleteSegmentsByPrefixTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "DeleteSegmentsByPrefixTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteSegmentsByPrefixTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeleteSegmentsByPrefixTask) String() string {
	s := make([]string, 0, 3)

	s = append(s, fmt.Sprintf("Prefix: %s", t.Prefix.String()))
	s = append(s, fmt.Sprintf("PrefixSegmentsLister: %s", t.PrefixSegmentsLister.String()))
	return fmt.Sprintf("DeleteSegmentsByPrefixTask {%s}", strings.Join(s, ", "))
}

// NewDeleteSegmentsByPrefixTask will create a DeleteSegmentsByPrefixTask which meets task.Task.
func NewDeleteSegmentsByPrefixTask(task task.Task) task.Task {
	return NewDeleteSegmentsByPrefix(task)
}

// DeleteStorageTask will delete a storage.
type DeleteStorageTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Service
	types.StorageName

	// Optional Input value
	types.Force
	types.HandleObjCallbackFunc
	types.HandleSegmentCallbackFunc
	types.Zone

	// Output value
}

// NewDeleteStorage will create a DeleteStorageTask struct and fetch inherited data from parent task.
func NewDeleteStorage(task task.Task) *DeleteStorageTask {
	t := &DeleteStorageTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteStorageTask) validateInput() {
	if !t.ValidateService() {
		panic(fmt.Errorf("Task DeleteStorage value Service is invalid"))
	}
	if !t.ValidateStorageName() {
		panic(fmt.Errorf("Task DeleteStorage value StorageName is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteStorageTask) loadInput(task task.Task) {
	// load required fields
	types.LoadService(task, t)
	types.LoadStorageName(task, t)
	// load optional fields
	types.LoadForce(task, t)
	types.LoadHandleObjCallbackFunc(task, t)
	types.LoadHandleSegmentCallbackFunc(task, t)
	types.LoadZone(task, t)
}

// Sync run sub task directly
func (t *DeleteStorageTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *DeleteStorageTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *DeleteStorageTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *DeleteStorageTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "DeleteStorageTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteStorageTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeleteStorageTask) String() string {
	s := make([]string, 0, 6)

	s = append(s, fmt.Sprintf("Service: %s", t.Service.String()))
	s = append(s, fmt.Sprintf("StorageName: %s", t.StorageName.String()))
	if t.ValidateForce() {
		s = append(s, fmt.Sprintf("Force: %s", t.Force.String()))
	}
	if t.ValidateZone() {
		s = append(s, fmt.Sprintf("Zone: %s", t.Zone.String()))
	}
	return fmt.Sprintf("DeleteStorageTask {%s}", strings.Join(s, ", "))
}

// NewDeleteStorageTask will create a DeleteStorageTask which meets task.Task.
func NewDeleteStorageTask(task task.Task) task.Task {
	return NewDeleteStorage(task)
}

// FetchTask will fetch object.
type FetchTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Fetcher
	types.Path
	types.URL

	// Optional Input value

	// Output value
}

// NewFetch will create a FetchTask struct and fetch inherited data from parent task.
func NewFetch(task task.Task) *FetchTask {
	t := &FetchTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *FetchTask) validateInput() {
	if !t.ValidateFetcher() {
		panic(fmt.Errorf("Task Fetch value Fetcher is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task Fetch value Path is invalid"))
	}
	if !t.ValidateURL() {
		panic(fmt.Errorf("Task Fetch value URL is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *FetchTask) loadInput(task task.Task) {
	// load required fields
	types.LoadFetcher(task, t)
	types.LoadPath(task, t)
	types.LoadURL(task, t)
	// load optional fields
}

// Sync run sub task directly
func (t *FetchTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *FetchTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *FetchTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *FetchTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "FetchTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *FetchTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *FetchTask) String() string {
	s := make([]string, 0, 3)

	s = append(s, fmt.Sprintf("Fetcher: %s", t.Fetcher.String()))
	s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	s = append(s, fmt.Sprintf("URL: %s", t.URL.String()))
	return fmt.Sprintf("FetchTask {%s}", strings.Join(s, ", "))
}

// NewFetchTask will create a FetchTask which meets task.Task.
func NewFetchTask(task task.Task) task.Task {
	return NewFetch(task)
}

// IsDestinationObjectExistTask will check if destination object exist.
type IsDestinationObjectExistTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.DestinationObject

	// Optional Input value

	// Output value
	types.Result
}

// NewIsDestinationObjectExist will create a IsDestinationObjectExistTask struct and fetch inherited data from parent task.
func NewIsDestinationObjectExist(task task.Task) *IsDestinationObjectExistTask {
	t := &IsDestinationObjectExistTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IsDestinationObjectExistTask) validateInput() {
	if !t.ValidateDestinationObject() {
		panic(fmt.Errorf("Task IsDestinationObjectExist value DestinationObject is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IsDestinationObjectExistTask) loadInput(task task.Task) {
	// load required fields
	types.LoadDestinationObject(task, t)
	// load optional fields
}

// Sync run sub task directly
func (t *IsDestinationObjectExistTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *IsDestinationObjectExistTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *IsDestinationObjectExistTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *IsDestinationObjectExistTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "IsDestinationObjectExistTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *IsDestinationObjectExistTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *IsDestinationObjectExistTask) String() string {
	s := make([]string, 0, 1)

	s = append(s, fmt.Sprintf("DestinationObject: %s", t.DestinationObject.String()))
	return fmt.Sprintf("IsDestinationObjectExistTask {%s}", strings.Join(s, ", "))
}

// NewIsDestinationObjectExistTask will create a IsDestinationObjectExistTask which meets task.Task.
func NewIsDestinationObjectExistTask(task task.Task) task.Task {
	return NewIsDestinationObjectExist(task)
}

// IsDestinationObjectNotExistTask will check if destination object not exist.
type IsDestinationObjectNotExistTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.DestinationObject

	// Optional Input value

	// Output value
	types.Result
}

// NewIsDestinationObjectNotExist will create a IsDestinationObjectNotExistTask struct and fetch inherited data from parent task.
func NewIsDestinationObjectNotExist(task task.Task) *IsDestinationObjectNotExistTask {
	t := &IsDestinationObjectNotExistTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IsDestinationObjectNotExistTask) validateInput() {
	if !t.ValidateDestinationObject() {
		panic(fmt.Errorf("Task IsDestinationObjectNotExist value DestinationObject is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IsDestinationObjectNotExistTask) loadInput(task task.Task) {
	// load required fields
	types.LoadDestinationObject(task, t)
	// load optional fields
}

// Sync run sub task directly
func (t *IsDestinationObjectNotExistTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *IsDestinationObjectNotExistTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *IsDestinationObjectNotExistTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *IsDestinationObjectNotExistTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "IsDestinationObjectNotExistTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *IsDestinationObjectNotExistTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *IsDestinationObjectNotExistTask) String() string {
	s := make([]string, 0, 1)

	s = append(s, fmt.Sprintf("DestinationObject: %s", t.DestinationObject.String()))
	return fmt.Sprintf("IsDestinationObjectNotExistTask {%s}", strings.Join(s, ", "))
}

// NewIsDestinationObjectNotExistTask will create a IsDestinationObjectNotExistTask which meets task.Task.
func NewIsDestinationObjectNotExistTask(task task.Task) task.Task {
	return NewIsDestinationObjectNotExist(task)
}

// IsSizeEqualTask will check if source object and destination object size equal.
type IsSizeEqualTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.DestinationObject
	types.SourceObject

	// Optional Input value

	// Output value
	types.Result
}

// NewIsSizeEqual will create a IsSizeEqualTask struct and fetch inherited data from parent task.
func NewIsSizeEqual(task task.Task) *IsSizeEqualTask {
	t := &IsSizeEqualTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IsSizeEqualTask) validateInput() {
	if !t.ValidateDestinationObject() {
		panic(fmt.Errorf("Task IsSizeEqual value DestinationObject is invalid"))
	}
	if !t.ValidateSourceObject() {
		panic(fmt.Errorf("Task IsSizeEqual value SourceObject is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IsSizeEqualTask) loadInput(task task.Task) {
	// load required fields
	types.LoadDestinationObject(task, t)
	types.LoadSourceObject(task, t)
	// load optional fields
}

// Sync run sub task directly
func (t *IsSizeEqualTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *IsSizeEqualTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *IsSizeEqualTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *IsSizeEqualTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "IsSizeEqualTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *IsSizeEqualTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *IsSizeEqualTask) String() string {
	s := make([]string, 0, 2)

	s = append(s, fmt.Sprintf("DestinationObject: %s", t.DestinationObject.String()))
	s = append(s, fmt.Sprintf("SourceObject: %s", t.SourceObject.String()))
	return fmt.Sprintf("IsSizeEqualTask {%s}", strings.Join(s, ", "))
}

// NewIsSizeEqualTask will create a IsSizeEqualTask which meets task.Task.
func NewIsSizeEqualTask(task task.Task) task.Task {
	return NewIsSizeEqual(task)
}

// IsSourcePathExcludeIncludeTask will check if source path is excluded or included.
type IsSourcePathExcludeIncludeTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.SourcePath

	// Optional Input value
	types.ExcludeRegexp
	types.IncludeRegexp

	// Output value
	types.Result
}

// NewIsSourcePathExcludeInclude will create a IsSourcePathExcludeIncludeTask struct and fetch inherited data from parent task.
func NewIsSourcePathExcludeInclude(task task.Task) *IsSourcePathExcludeIncludeTask {
	t := &IsSourcePathExcludeIncludeTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IsSourcePathExcludeIncludeTask) validateInput() {
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task IsSourcePathExcludeInclude value SourcePath is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IsSourcePathExcludeIncludeTask) loadInput(task task.Task) {
	// load required fields
	types.LoadSourcePath(task, t)
	// load optional fields
	types.LoadExcludeRegexp(task, t)
	types.LoadIncludeRegexp(task, t)
}

// Sync run sub task directly
func (t *IsSourcePathExcludeIncludeTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *IsSourcePathExcludeIncludeTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *IsSourcePathExcludeIncludeTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *IsSourcePathExcludeIncludeTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "IsSourcePathExcludeIncludeTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *IsSourcePathExcludeIncludeTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *IsSourcePathExcludeIncludeTask) String() string {
	s := make([]string, 0, 3)

	s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	if t.ValidateExcludeRegexp() {
		s = append(s, fmt.Sprintf("ExcludeRegexp: %s", t.ExcludeRegexp.String()))
	}
	if t.ValidateIncludeRegexp() {
		s = append(s, fmt.Sprintf("IncludeRegexp: %s", t.IncludeRegexp.String()))
	}
	return fmt.Sprintf("IsSourcePathExcludeIncludeTask {%s}", strings.Join(s, ", "))
}

// NewIsSourcePathExcludeIncludeTask will create a IsSourcePathExcludeIncludeTask which meets task.Task.
func NewIsSourcePathExcludeIncludeTask(task task.Task) task.Task {
	return NewIsSourcePathExcludeInclude(task)
}

// IsUpdateAtGreaterTask will check if source object's mtime is greater (newer) than destination object's.
type IsUpdateAtGreaterTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.DestinationObject
	types.SourceObject

	// Optional Input value

	// Output value
	types.Result
}

// NewIsUpdateAtGreater will create a IsUpdateAtGreaterTask struct and fetch inherited data from parent task.
func NewIsUpdateAtGreater(task task.Task) *IsUpdateAtGreaterTask {
	t := &IsUpdateAtGreaterTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IsUpdateAtGreaterTask) validateInput() {
	if !t.ValidateDestinationObject() {
		panic(fmt.Errorf("Task IsUpdateAtGreater value DestinationObject is invalid"))
	}
	if !t.ValidateSourceObject() {
		panic(fmt.Errorf("Task IsUpdateAtGreater value SourceObject is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IsUpdateAtGreaterTask) loadInput(task task.Task) {
	// load required fields
	types.LoadDestinationObject(task, t)
	types.LoadSourceObject(task, t)
	// load optional fields
}

// Sync run sub task directly
func (t *IsUpdateAtGreaterTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *IsUpdateAtGreaterTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *IsUpdateAtGreaterTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *IsUpdateAtGreaterTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "IsUpdateAtGreaterTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *IsUpdateAtGreaterTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *IsUpdateAtGreaterTask) String() string {
	s := make([]string, 0, 2)

	s = append(s, fmt.Sprintf("DestinationObject: %s", t.DestinationObject.String()))
	s = append(s, fmt.Sprintf("SourceObject: %s", t.SourceObject.String()))
	return fmt.Sprintf("IsUpdateAtGreaterTask {%s}", strings.Join(s, ", "))
}

// NewIsUpdateAtGreaterTask will create a IsUpdateAtGreaterTask which meets task.Task.
func NewIsUpdateAtGreaterTask(task task.Task) task.Task {
	return NewIsUpdateAtGreater(task)
}

// ListDirTask will list dirs.
type ListDirTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.DirLister
	types.Path

	// Optional Input value

	// Output value
	types.ObjectIter
}

// NewListDir will create a ListDirTask struct and fetch inherited data from parent task.
func NewListDir(task task.Task) *ListDirTask {
	t := &ListDirTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ListDirTask) validateInput() {
	if !t.ValidateDirLister() {
		panic(fmt.Errorf("Task ListDir value DirLister is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ListDir value Path is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ListDirTask) loadInput(task task.Task) {
	// load required fields
	types.LoadDirLister(task, t)
	types.LoadPath(task, t)
	// load optional fields
}

// Sync run sub task directly
func (t *ListDirTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *ListDirTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *ListDirTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *ListDirTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "ListDirTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *ListDirTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ListDirTask) String() string {
	s := make([]string, 0, 2)

	s = append(s, fmt.Sprintf("DirLister: %s", t.DirLister.String()))
	s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	return fmt.Sprintf("ListDirTask {%s}", strings.Join(s, ", "))
}

// NewListDirTask will create a ListDirTask which meets task.Task.
func NewListDirTask(task task.Task) task.Task {
	return NewListDir(task)
}

// ListPrefixTask will list prefix.
type ListPrefixTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Path
	types.PrefixLister

	// Optional Input value

	// Output value
	types.ObjectIter
}

// NewListPrefix will create a ListPrefixTask struct and fetch inherited data from parent task.
func NewListPrefix(task task.Task) *ListPrefixTask {
	t := &ListPrefixTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ListPrefixTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ListPrefix value Path is invalid"))
	}
	if !t.ValidatePrefixLister() {
		panic(fmt.Errorf("Task ListPrefix value PrefixLister is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ListPrefixTask) loadInput(task task.Task) {
	// load required fields
	types.LoadPath(task, t)
	types.LoadPrefixLister(task, t)
	// load optional fields
}

// Sync run sub task directly
func (t *ListPrefixTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *ListPrefixTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *ListPrefixTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *ListPrefixTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "ListPrefixTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *ListPrefixTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ListPrefixTask) String() string {
	s := make([]string, 0, 2)

	s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	s = append(s, fmt.Sprintf("PrefixLister: %s", t.PrefixLister.String()))
	return fmt.Sprintf("ListPrefixTask {%s}", strings.Join(s, ", "))
}

// NewListPrefixTask will create a ListPrefixTask which meets task.Task.
func NewListPrefixTask(task task.Task) task.Task {
	return NewListPrefix(task)
}

// ListSegmentTask will list segments.
type ListSegmentTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Path
	types.PrefixSegmentsLister

	// Optional Input value

	// Output value
	types.SegmentIter
}

// NewListSegment will create a ListSegmentTask struct and fetch inherited data from parent task.
func NewListSegment(task task.Task) *ListSegmentTask {
	t := &ListSegmentTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ListSegmentTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ListSegment value Path is invalid"))
	}
	if !t.ValidatePrefixSegmentsLister() {
		panic(fmt.Errorf("Task ListSegment value PrefixSegmentsLister is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ListSegmentTask) loadInput(task task.Task) {
	// load required fields
	types.LoadPath(task, t)
	types.LoadPrefixSegmentsLister(task, t)
	// load optional fields
}

// Sync run sub task directly
func (t *ListSegmentTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *ListSegmentTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *ListSegmentTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *ListSegmentTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "ListSegmentTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *ListSegmentTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ListSegmentTask) String() string {
	s := make([]string, 0, 2)

	s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	s = append(s, fmt.Sprintf("PrefixSegmentsLister: %s", t.PrefixSegmentsLister.String()))
	return fmt.Sprintf("ListSegmentTask {%s}", strings.Join(s, ", "))
}

// NewListSegmentTask will create a ListSegmentTask which meets task.Task.
func NewListSegmentTask(task task.Task) task.Task {
	return NewListSegment(task)
}

// ListStorageTask will send get request to get bucket list.
type ListStorageTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Service

	// Optional Input value
	types.Zone

	// Output value
	types.StorageIter
}

// NewListStorage will create a ListStorageTask struct and fetch inherited data from parent task.
func NewListStorage(task task.Task) *ListStorageTask {
	t := &ListStorageTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ListStorageTask) validateInput() {
	if !t.ValidateService() {
		panic(fmt.Errorf("Task ListStorage value Service is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ListStorageTask) loadInput(task task.Task) {
	// load required fields
	types.LoadService(task, t)
	// load optional fields
	types.LoadZone(task, t)
}

// Sync run sub task directly
func (t *ListStorageTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *ListStorageTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *ListStorageTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *ListStorageTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "ListStorageTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *ListStorageTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ListStorageTask) String() string {
	s := make([]string, 0, 2)

	s = append(s, fmt.Sprintf("Service: %s", t.Service.String()))
	if t.ValidateZone() {
		s = append(s, fmt.Sprintf("Zone: %s", t.Zone.String()))
	}
	return fmt.Sprintf("ListStorageTask {%s}", strings.Join(s, ", "))
}

// NewListStorageTask will create a ListStorageTask which meets task.Task.
func NewListStorageTask(task task.Task) task.Task {
	return NewListStorage(task)
}

// MD5SumFileTask will get file's md5 sum.
type MD5SumFileTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Offset
	types.Path
	types.Size
	types.Storage

	// Optional Input value

	// Output value
	types.MD5Sum
}

// NewMD5SumFile will create a MD5SumFileTask struct and fetch inherited data from parent task.
func NewMD5SumFile(task task.Task) *MD5SumFileTask {
	t := &MD5SumFileTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MD5SumFileTask) validateInput() {
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task MD5SumFile value Offset is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task MD5SumFile value Path is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task MD5SumFile value Size is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task MD5SumFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MD5SumFileTask) loadInput(task task.Task) {
	// load required fields
	types.LoadOffset(task, t)
	types.LoadPath(task, t)
	types.LoadSize(task, t)
	types.LoadStorage(task, t)
	// load optional fields
}

// Sync run sub task directly
func (t *MD5SumFileTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *MD5SumFileTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *MD5SumFileTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *MD5SumFileTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "MD5SumFileTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *MD5SumFileTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *MD5SumFileTask) String() string {
	s := make([]string, 0, 4)

	s = append(s, fmt.Sprintf("Offset: %s", t.Offset.String()))
	s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	s = append(s, fmt.Sprintf("Size: %s", t.Size.String()))
	s = append(s, fmt.Sprintf("Storage: %s", t.Storage.String()))
	return fmt.Sprintf("MD5SumFileTask {%s}", strings.Join(s, ", "))
}

// NewMD5SumFileTask will create a MD5SumFileTask which meets task.Task.
func NewMD5SumFileTask(task task.Task) task.Task {
	return NewMD5SumFile(task)
}

// MD5SumStreamTask will get stream's md5 sum.
type MD5SumStreamTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Content

	// Optional Input value

	// Output value
	types.MD5Sum
}

// NewMD5SumStream will create a MD5SumStreamTask struct and fetch inherited data from parent task.
func NewMD5SumStream(task task.Task) *MD5SumStreamTask {
	t := &MD5SumStreamTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MD5SumStreamTask) validateInput() {
	if !t.ValidateContent() {
		panic(fmt.Errorf("Task MD5SumStream value Content is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MD5SumStreamTask) loadInput(task task.Task) {
	// load required fields
	types.LoadContent(task, t)
	// load optional fields
}

// Sync run sub task directly
func (t *MD5SumStreamTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *MD5SumStreamTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *MD5SumStreamTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *MD5SumStreamTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "MD5SumStreamTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *MD5SumStreamTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *MD5SumStreamTask) String() string {
	s := make([]string, 0, 1)

	s = append(s, fmt.Sprintf("Content: %s", t.Content.String()))
	return fmt.Sprintf("MD5SumStreamTask {%s}", strings.Join(s, ", "))
}

// NewMD5SumStreamTask will create a MD5SumStreamTask which meets task.Task.
func NewMD5SumStreamTask(task task.Task) task.Task {
	return NewMD5SumStream(task)
}

// MoveDirTask will move a directory recursively between two storager.
type MoveDirTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Optional Input value
	types.CheckMD5
	types.CheckTasks
	types.HandleObjCallbackFunc
	types.PartSize
	types.PartThreshold

	// Output value
}

// NewMoveDir will create a MoveDirTask struct and fetch inherited data from parent task.
func NewMoveDir(task task.Task) *MoveDirTask {
	t := &MoveDirTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MoveDirTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task MoveDir value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task MoveDir value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task MoveDir value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task MoveDir value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MoveDirTask) loadInput(task task.Task) {
	// load required fields
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	// load optional fields
	types.LoadCheckMD5(task, t)
	types.LoadCheckTasks(task, t)
	types.LoadHandleObjCallbackFunc(task, t)
	types.LoadPartSize(task, t)
	types.LoadPartThreshold(task, t)
}

// Sync run sub task directly
func (t *MoveDirTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *MoveDirTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *MoveDirTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *MoveDirTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "MoveDirTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *MoveDirTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *MoveDirTask) String() string {
	s := make([]string, 0, 9)

	s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidateCheckTasks() {
		s = append(s, fmt.Sprintf("CheckTasks: %s", t.CheckTasks.String()))
	}
	if t.ValidatePartSize() {
		s = append(s, fmt.Sprintf("PartSize: %s", t.PartSize.String()))
	}
	if t.ValidatePartThreshold() {
		s = append(s, fmt.Sprintf("PartThreshold: %s", t.PartThreshold.String()))
	}
	return fmt.Sprintf("MoveDirTask {%s}", strings.Join(s, ", "))
}

// NewMoveDirTask will create a MoveDirTask which meets task.Task.
func NewMoveDirTask(task task.Task) task.Task {
	return NewMoveDir(task)
}

// MoveFileTask will move a file between two storager.
type MoveFileTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Optional Input value
	types.CheckMD5
	types.CheckTasks
	types.HandleObjCallbackFunc
	types.PartSize
	types.PartThreshold

	// Output value
}

// NewMoveFile will create a MoveFileTask struct and fetch inherited data from parent task.
func NewMoveFile(task task.Task) *MoveFileTask {
	t := &MoveFileTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MoveFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task MoveFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task MoveFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task MoveFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task MoveFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MoveFileTask) loadInput(task task.Task) {
	// load required fields
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	// load optional fields
	types.LoadCheckMD5(task, t)
	types.LoadCheckTasks(task, t)
	types.LoadHandleObjCallbackFunc(task, t)
	types.LoadPartSize(task, t)
	types.LoadPartThreshold(task, t)
}

// Sync run sub task directly
func (t *MoveFileTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *MoveFileTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *MoveFileTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *MoveFileTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "MoveFileTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *MoveFileTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *MoveFileTask) String() string {
	s := make([]string, 0, 9)

	s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidateCheckTasks() {
		s = append(s, fmt.Sprintf("CheckTasks: %s", t.CheckTasks.String()))
	}
	if t.ValidatePartSize() {
		s = append(s, fmt.Sprintf("PartSize: %s", t.PartSize.String()))
	}
	if t.ValidatePartThreshold() {
		s = append(s, fmt.Sprintf("PartThreshold: %s", t.PartThreshold.String()))
	}
	return fmt.Sprintf("MoveFileTask {%s}", strings.Join(s, ", "))
}

// NewMoveFileTask will create a MoveFileTask which meets task.Task.
func NewMoveFileTask(task task.Task) task.Task {
	return NewMoveFile(task)
}

// ReachFileTask will will reach a remote object and return the signed url.
type ReachFileTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Expire
	types.Path
	types.Reacher

	// Optional Input value

	// Output value
	types.URL
}

// NewReachFile will create a ReachFileTask struct and fetch inherited data from parent task.
func NewReachFile(task task.Task) *ReachFileTask {
	t := &ReachFileTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ReachFileTask) validateInput() {
	if !t.ValidateExpire() {
		panic(fmt.Errorf("Task ReachFile value Expire is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ReachFile value Path is invalid"))
	}
	if !t.ValidateReacher() {
		panic(fmt.Errorf("Task ReachFile value Reacher is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ReachFileTask) loadInput(task task.Task) {
	// load required fields
	types.LoadExpire(task, t)
	types.LoadPath(task, t)
	types.LoadReacher(task, t)
	// load optional fields
}

// Sync run sub task directly
func (t *ReachFileTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *ReachFileTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *ReachFileTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *ReachFileTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "ReachFileTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *ReachFileTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ReachFileTask) String() string {
	s := make([]string, 0, 3)

	s = append(s, fmt.Sprintf("Expire: %s", t.Expire.String()))
	s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	s = append(s, fmt.Sprintf("Reacher: %s", t.Reacher.String()))
	return fmt.Sprintf("ReachFileTask {%s}", strings.Join(s, ", "))
}

// NewReachFileTask will create a ReachFileTask which meets task.Task.
func NewReachFileTask(task task.Task) task.Task {
	return NewReachFile(task)
}

// ReadFileTask will read file from storage.
type ReadFileTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Path
	types.Storage
	types.WriteCloser

	// Optional Input value
	types.Offset
	types.ReadCallBackFunc
	types.Size

	// Output value
}

// NewReadFile will create a ReadFileTask struct and fetch inherited data from parent task.
func NewReadFile(task task.Task) *ReadFileTask {
	t := &ReadFileTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ReadFileTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ReadFile value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task ReadFile value Storage is invalid"))
	}
	if !t.ValidateWriteCloser() {
		panic(fmt.Errorf("Task ReadFile value WriteCloser is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ReadFileTask) loadInput(task task.Task) {
	// load required fields
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
	types.LoadWriteCloser(task, t)
	// load optional fields
	types.LoadOffset(task, t)
	types.LoadReadCallBackFunc(task, t)
	types.LoadSize(task, t)
}

// Sync run sub task directly
func (t *ReadFileTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *ReadFileTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *ReadFileTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *ReadFileTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "ReadFileTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *ReadFileTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ReadFileTask) String() string {
	s := make([]string, 0, 6)

	s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	s = append(s, fmt.Sprintf("Storage: %s", t.Storage.String()))
	s = append(s, fmt.Sprintf("WriteCloser: %s", t.WriteCloser.String()))
	if t.ValidateOffset() {
		s = append(s, fmt.Sprintf("Offset: %s", t.Offset.String()))
	}
	if t.ValidateSize() {
		s = append(s, fmt.Sprintf("Size: %s", t.Size.String()))
	}
	return fmt.Sprintf("ReadFileTask {%s}", strings.Join(s, ", "))
}

// NewReadFileTask will create a ReadFileTask which meets task.Task.
func NewReadFileTask(task task.Task) task.Task {
	return NewReadFile(task)
}

// SegmentCompleteTask will complete a segment.
type SegmentCompleteTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.IndexSegmenter
	types.Path
	types.Segment

	// Optional Input value

	// Output value
}

// NewSegmentComplete will create a SegmentCompleteTask struct and fetch inherited data from parent task.
func NewSegmentComplete(task task.Task) *SegmentCompleteTask {
	t := &SegmentCompleteTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentCompleteTask) validateInput() {
	if !t.ValidateIndexSegmenter() {
		panic(fmt.Errorf("Task SegmentComplete value IndexSegmenter is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task SegmentComplete value Path is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task SegmentComplete value Segment is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentCompleteTask) loadInput(task task.Task) {
	// load required fields
	types.LoadIndexSegmenter(task, t)
	types.LoadPath(task, t)
	types.LoadSegment(task, t)
	// load optional fields
}

// Sync run sub task directly
func (t *SegmentCompleteTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *SegmentCompleteTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *SegmentCompleteTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *SegmentCompleteTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "SegmentCompleteTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentCompleteTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SegmentCompleteTask) String() string {
	s := make([]string, 0, 3)

	s = append(s, fmt.Sprintf("IndexSegmenter: %s", t.IndexSegmenter.String()))
	s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	s = append(s, fmt.Sprintf("Segment: %s", t.Segment.String()))
	return fmt.Sprintf("SegmentCompleteTask {%s}", strings.Join(s, ", "))
}

// NewSegmentCompleteTask will create a SegmentCompleteTask which meets task.Task.
func NewSegmentCompleteTask(task task.Task) task.Task {
	return NewSegmentComplete(task)
}

// SegmentFileCopyTask will copy a segment file.
type SegmentFileCopyTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.DestinationIndexSegmenter
	types.DestinationPath
	types.Index
	types.Offset
	types.Segment
	types.Size
	types.SourcePath
	types.SourceStorage

	// Optional Input value
	types.MD5Sum

	// Output value
}

// NewSegmentFileCopy will create a SegmentFileCopyTask struct and fetch inherited data from parent task.
func NewSegmentFileCopy(task task.Task) *SegmentFileCopyTask {
	t := &SegmentFileCopyTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentFileCopyTask) validateInput() {
	if !t.ValidateDestinationIndexSegmenter() {
		panic(fmt.Errorf("Task SegmentFileCopy value DestinationIndexSegmenter is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task SegmentFileCopy value DestinationPath is invalid"))
	}
	if !t.ValidateIndex() {
		panic(fmt.Errorf("Task SegmentFileCopy value Index is invalid"))
	}
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task SegmentFileCopy value Offset is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task SegmentFileCopy value Segment is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task SegmentFileCopy value Size is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task SegmentFileCopy value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task SegmentFileCopy value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentFileCopyTask) loadInput(task task.Task) {
	// load required fields
	types.LoadDestinationIndexSegmenter(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadIndex(task, t)
	types.LoadOffset(task, t)
	types.LoadSegment(task, t)
	types.LoadSize(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	// load optional fields
	types.LoadMD5Sum(task, t)
}

// Sync run sub task directly
func (t *SegmentFileCopyTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *SegmentFileCopyTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *SegmentFileCopyTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *SegmentFileCopyTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "SegmentFileCopyTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentFileCopyTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SegmentFileCopyTask) String() string {
	s := make([]string, 0, 9)

	s = append(s, fmt.Sprintf("DestinationIndexSegmenter: %s", t.DestinationIndexSegmenter.String()))
	s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	s = append(s, fmt.Sprintf("Index: %s", t.Index.String()))
	s = append(s, fmt.Sprintf("Offset: %s", t.Offset.String()))
	s = append(s, fmt.Sprintf("Segment: %s", t.Segment.String()))
	s = append(s, fmt.Sprintf("Size: %s", t.Size.String()))
	s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	if t.ValidateMD5Sum() {
		s = append(s, fmt.Sprintf("MD5Sum: %s", t.MD5Sum.String()))
	}
	return fmt.Sprintf("SegmentFileCopyTask {%s}", strings.Join(s, ", "))
}

// NewSegmentFileCopyTask will create a SegmentFileCopyTask which meets task.Task.
func NewSegmentFileCopyTask(task task.Task) task.Task {
	return NewSegmentFileCopy(task)
}

// SegmentInitTask will init a segment upload.
type SegmentInitTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.IndexSegmenter
	types.PartSize
	types.Path

	// Optional Input value

	// Output value
	types.Segment
}

// NewSegmentInit will create a SegmentInitTask struct and fetch inherited data from parent task.
func NewSegmentInit(task task.Task) *SegmentInitTask {
	t := &SegmentInitTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentInitTask) validateInput() {
	if !t.ValidateIndexSegmenter() {
		panic(fmt.Errorf("Task SegmentInit value IndexSegmenter is invalid"))
	}
	if !t.ValidatePartSize() {
		panic(fmt.Errorf("Task SegmentInit value PartSize is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task SegmentInit value Path is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentInitTask) loadInput(task task.Task) {
	// load required fields
	types.LoadIndexSegmenter(task, t)
	types.LoadPartSize(task, t)
	types.LoadPath(task, t)
	// load optional fields
}

// Sync run sub task directly
func (t *SegmentInitTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *SegmentInitTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *SegmentInitTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *SegmentInitTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "SegmentInitTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentInitTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SegmentInitTask) String() string {
	s := make([]string, 0, 3)

	s = append(s, fmt.Sprintf("IndexSegmenter: %s", t.IndexSegmenter.String()))
	s = append(s, fmt.Sprintf("PartSize: %s", t.PartSize.String()))
	s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	return fmt.Sprintf("SegmentInitTask {%s}", strings.Join(s, ", "))
}

// NewSegmentInitTask will create a SegmentInitTask which meets task.Task.
func NewSegmentInitTask(task task.Task) task.Task {
	return NewSegmentInit(task)
}

// SegmentStreamCopyTask will copy a segment stream.
type SegmentStreamCopyTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Content
	types.DestinationIndexSegmenter
	types.DestinationPath
	types.Index
	types.Offset
	types.Segment
	types.Size

	// Optional Input value
	types.MD5Sum

	// Output value
}

// NewSegmentStreamCopy will create a SegmentStreamCopyTask struct and fetch inherited data from parent task.
func NewSegmentStreamCopy(task task.Task) *SegmentStreamCopyTask {
	t := &SegmentStreamCopyTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentStreamCopyTask) validateInput() {
	if !t.ValidateContent() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Content is invalid"))
	}
	if !t.ValidateDestinationIndexSegmenter() {
		panic(fmt.Errorf("Task SegmentStreamCopy value DestinationIndexSegmenter is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task SegmentStreamCopy value DestinationPath is invalid"))
	}
	if !t.ValidateIndex() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Index is invalid"))
	}
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Offset is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Segment is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Size is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentStreamCopyTask) loadInput(task task.Task) {
	// load required fields
	types.LoadContent(task, t)
	types.LoadDestinationIndexSegmenter(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadIndex(task, t)
	types.LoadOffset(task, t)
	types.LoadSegment(task, t)
	types.LoadSize(task, t)
	// load optional fields
	types.LoadMD5Sum(task, t)
}

// Sync run sub task directly
func (t *SegmentStreamCopyTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *SegmentStreamCopyTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *SegmentStreamCopyTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *SegmentStreamCopyTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "SegmentStreamCopyTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentStreamCopyTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SegmentStreamCopyTask) String() string {
	s := make([]string, 0, 8)

	s = append(s, fmt.Sprintf("Content: %s", t.Content.String()))
	s = append(s, fmt.Sprintf("DestinationIndexSegmenter: %s", t.DestinationIndexSegmenter.String()))
	s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	s = append(s, fmt.Sprintf("Index: %s", t.Index.String()))
	s = append(s, fmt.Sprintf("Offset: %s", t.Offset.String()))
	s = append(s, fmt.Sprintf("Segment: %s", t.Segment.String()))
	s = append(s, fmt.Sprintf("Size: %s", t.Size.String()))
	if t.ValidateMD5Sum() {
		s = append(s, fmt.Sprintf("MD5Sum: %s", t.MD5Sum.String()))
	}
	return fmt.Sprintf("SegmentStreamCopyTask {%s}", strings.Join(s, ", "))
}

// NewSegmentStreamCopyTask will create a SegmentStreamCopyTask which meets task.Task.
func NewSegmentStreamCopyTask(task task.Task) task.Task {
	return NewSegmentStreamCopy(task)
}

// SegmentStreamInitTask will init a partial stream between two storager.
type SegmentStreamInitTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.BytesPool
	types.PartSize
	types.SourcePath
	types.SourceStorage

	// Optional Input value

	// Output value
	types.Content
	types.Done
	types.Size
}

// NewSegmentStreamInit will create a SegmentStreamInitTask struct and fetch inherited data from parent task.
func NewSegmentStreamInit(task task.Task) *SegmentStreamInitTask {
	t := &SegmentStreamInitTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentStreamInitTask) validateInput() {
	if !t.ValidateBytesPool() {
		panic(fmt.Errorf("Task SegmentStreamInit value BytesPool is invalid"))
	}
	if !t.ValidatePartSize() {
		panic(fmt.Errorf("Task SegmentStreamInit value PartSize is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task SegmentStreamInit value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task SegmentStreamInit value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentStreamInitTask) loadInput(task task.Task) {
	// load required fields
	types.LoadBytesPool(task, t)
	types.LoadPartSize(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	// load optional fields
}

// Sync run sub task directly
func (t *SegmentStreamInitTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *SegmentStreamInitTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *SegmentStreamInitTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *SegmentStreamInitTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "SegmentStreamInitTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentStreamInitTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SegmentStreamInitTask) String() string {
	s := make([]string, 0, 4)

	s = append(s, fmt.Sprintf("BytesPool: %s", t.BytesPool.String()))
	s = append(s, fmt.Sprintf("PartSize: %s", t.PartSize.String()))
	s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	return fmt.Sprintf("SegmentStreamInitTask {%s}", strings.Join(s, ", "))
}

// NewSegmentStreamInitTask will create a SegmentStreamInitTask which meets task.Task.
func NewSegmentStreamInitTask(task task.Task) task.Task {
	return NewSegmentStreamInit(task)
}

// StatFileTask will stat a remote object by request headObject.
type StatFileTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Path
	types.Storage

	// Optional Input value

	// Output value
	types.Object
}

// NewStatFile will create a StatFileTask struct and fetch inherited data from parent task.
func NewStatFile(task task.Task) *StatFileTask {
	t := &StatFileTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *StatFileTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task StatFile value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task StatFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *StatFileTask) loadInput(task task.Task) {
	// load required fields
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
	// load optional fields
}

// Sync run sub task directly
func (t *StatFileTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *StatFileTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *StatFileTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *StatFileTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "StatFileTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *StatFileTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *StatFileTask) String() string {
	s := make([]string, 0, 2)

	s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	s = append(s, fmt.Sprintf("Storage: %s", t.Storage.String()))
	return fmt.Sprintf("StatFileTask {%s}", strings.Join(s, ", "))
}

// NewStatFileTask will create a StatFileTask which meets task.Task.
func NewStatFileTask(task task.Task) task.Task {
	return NewStatFile(task)
}

// StatStorageTask will stat a remote storage by Statistical.
type StatStorageTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Storage

	// Optional Input value

	// Output value
	types.StorageInfo
}

// NewStatStorage will create a StatStorageTask struct and fetch inherited data from parent task.
func NewStatStorage(task task.Task) *StatStorageTask {
	t := &StatStorageTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *StatStorageTask) validateInput() {
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task StatStorage value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *StatStorageTask) loadInput(task task.Task) {
	// load required fields
	types.LoadStorage(task, t)
	// load optional fields
}

// Sync run sub task directly
func (t *StatStorageTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *StatStorageTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *StatStorageTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *StatStorageTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "StatStorageTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *StatStorageTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *StatStorageTask) String() string {
	s := make([]string, 0, 1)

	s = append(s, fmt.Sprintf("Storage: %s", t.Storage.String()))
	return fmt.Sprintf("StatStorageTask {%s}", strings.Join(s, ", "))
}

// NewStatStorageTask will create a StatStorageTask which meets task.Task.
func NewStatStorageTask(task task.Task) task.Task {
	return NewStatStorage(task)
}

// SyncTask will sync directory between two storage.
type SyncTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Optional Input value
	types.CheckMD5
	types.CheckTasks
	types.DryRunFunc
	types.HandleObjCallbackFunc
	types.PartSize
	types.PartThreshold
	types.Recursive

	// Output value
}

// NewSync will create a SyncTask struct and fetch inherited data from parent task.
func NewSync(task task.Task) *SyncTask {
	t := &SyncTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SyncTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task Sync value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task Sync value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task Sync value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task Sync value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SyncTask) loadInput(task task.Task) {
	// load required fields
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	// load optional fields
	types.LoadCheckMD5(task, t)
	types.LoadCheckTasks(task, t)
	types.LoadDryRunFunc(task, t)
	types.LoadHandleObjCallbackFunc(task, t)
	types.LoadPartSize(task, t)
	types.LoadPartThreshold(task, t)
	types.LoadRecursive(task, t)
}

// Sync run sub task directly
func (t *SyncTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *SyncTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *SyncTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *SyncTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "SyncTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *SyncTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SyncTask) String() string {
	s := make([]string, 0, 11)

	s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidateCheckTasks() {
		s = append(s, fmt.Sprintf("CheckTasks: %s", t.CheckTasks.String()))
	}
	if t.ValidatePartSize() {
		s = append(s, fmt.Sprintf("PartSize: %s", t.PartSize.String()))
	}
	if t.ValidatePartThreshold() {
		s = append(s, fmt.Sprintf("PartThreshold: %s", t.PartThreshold.String()))
	}
	if t.ValidateRecursive() {
		s = append(s, fmt.Sprintf("Recursive: %s", t.Recursive.String()))
	}
	return fmt.Sprintf("SyncTask {%s}", strings.Join(s, ", "))
}

// NewSyncTask will create a SyncTask which meets task.Task.
func NewSyncTask(task task.Task) task.Task {
	return NewSync(task)
}

// WriteFileTask will write file to storage.
type WriteFileTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Path
	types.ReadCloser
	types.Storage

	// Optional Input value
	types.Offset
	types.ReadCallBackFunc
	types.Size
	types.StorageClass

	// Output value
}

// NewWriteFile will create a WriteFileTask struct and fetch inherited data from parent task.
func NewWriteFile(task task.Task) *WriteFileTask {
	t := &WriteFileTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *WriteFileTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task WriteFile value Path is invalid"))
	}
	if !t.ValidateReadCloser() {
		panic(fmt.Errorf("Task WriteFile value ReadCloser is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task WriteFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *WriteFileTask) loadInput(task task.Task) {
	// load required fields
	types.LoadPath(task, t)
	types.LoadReadCloser(task, t)
	types.LoadStorage(task, t)
	// load optional fields
	types.LoadOffset(task, t)
	types.LoadReadCallBackFunc(task, t)
	types.LoadSize(task, t)
	types.LoadStorageClass(task, t)
}

// Sync run sub task directly
func (t *WriteFileTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *WriteFileTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *WriteFileTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *WriteFileTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "WriteFileTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *WriteFileTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *WriteFileTask) String() string {
	s := make([]string, 0, 7)

	s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	s = append(s, fmt.Sprintf("ReadCloser: %s", t.ReadCloser.String()))
	s = append(s, fmt.Sprintf("Storage: %s", t.Storage.String()))
	if t.ValidateOffset() {
		s = append(s, fmt.Sprintf("Offset: %s", t.Offset.String()))
	}
	if t.ValidateSize() {
		s = append(s, fmt.Sprintf("Size: %s", t.Size.String()))
	}
	if t.ValidateStorageClass() {
		s = append(s, fmt.Sprintf("StorageClass: %s", t.StorageClass.String()))
	}
	return fmt.Sprintf("WriteFileTask {%s}", strings.Join(s, ", "))
}

// NewWriteFileTask will create a WriteFileTask which meets task.Task.
func NewWriteFileTask(task task.Task) task.Task {
	return NewWriteFile(task)
}

// WriteSegmentTask will write segment to storage.
type WriteSegmentTask struct {
	// Predefined value
	types.Scheduler
	types.ID
	types.CallbackFunc

	// Required Input value
	types.Index
	types.IndexSegmenter
	types.ReadCloser
	types.Segment
	types.Size

	// Optional Input value
	types.Path
	types.ReadCallBackFunc

	// Output value
}

// NewWriteSegment will create a WriteSegmentTask struct and fetch inherited data from parent task.
func NewWriteSegment(task task.Task) *WriteSegmentTask {
	t := &WriteSegmentTask{}
	t.SetScheduler(schedule.New())
	t.SetID(uuid.New().String())

	t.loadInput(task)

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *WriteSegmentTask) validateInput() {
	if !t.ValidateIndex() {
		panic(fmt.Errorf("Task WriteSegment value Index is invalid"))
	}
	if !t.ValidateIndexSegmenter() {
		panic(fmt.Errorf("Task WriteSegment value IndexSegmenter is invalid"))
	}
	if !t.ValidateReadCloser() {
		panic(fmt.Errorf("Task WriteSegment value ReadCloser is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task WriteSegment value Segment is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task WriteSegment value Size is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *WriteSegmentTask) loadInput(task task.Task) {
	// load required fields
	types.LoadIndex(task, t)
	types.LoadIndexSegmenter(task, t)
	types.LoadReadCloser(task, t)
	types.LoadSegment(task, t)
	types.LoadSize(task, t)
	// load optional fields
	types.LoadPath(task, t)
	types.LoadReadCallBackFunc(task, t)
}

// Sync run sub task directly
func (t *WriteSegmentTask) Sync(ctx context.Context, st task.Task) error {
	return st.Run(ctx)
}

// Async run sub task asynchronously
func (t *WriteSegmentTask) Async(ctx context.Context, st task.Task) {
	t.GetScheduler().Add(1)
	go func() {
		defer t.GetScheduler().Done()
		if err := st.Run(ctx); err != nil {
			t.TriggerFault(err)
		}
	}()
}

// Await wait sub task done
func (t *WriteSegmentTask) Await() error {
	return t.GetScheduler().Await()
}

// Run implement task.Task
func (t *WriteSegmentTask) Run(ctx context.Context) error {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	err := t.run(ctx)
	if err != nil {
		t.TriggerFault(err)
	}

	if err := t.Await(); err != nil {
		logger.Debug(
			log.String("task_failed", "WriteSegmentTask"),
			log.String("err", err.Error()),
		)
		return err
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
	return nil
}

// TriggerFault will be used to trigger a task related fault.
func (t *WriteSegmentTask) TriggerFault(err error) {
	t.GetScheduler().AppendFault(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *WriteSegmentTask) String() string {
	s := make([]string, 0, 7)

	s = append(s, fmt.Sprintf("Index: %s", t.Index.String()))
	s = append(s, fmt.Sprintf("IndexSegmenter: %s", t.IndexSegmenter.String()))
	s = append(s, fmt.Sprintf("ReadCloser: %s", t.ReadCloser.String()))
	s = append(s, fmt.Sprintf("Segment: %s", t.Segment.String()))
	s = append(s, fmt.Sprintf("Size: %s", t.Size.String()))
	if t.ValidatePath() {
		s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	}
	return fmt.Sprintf("WriteSegmentTask {%s}", strings.Join(s, ", "))
}

// NewWriteSegmentTask will create a WriteSegmentTask which meets task.Task.
func NewWriteSegmentTask(task task.Task) task.Task {
	return NewWriteSegment(task)
}
