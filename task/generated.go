// Code generated by go generate; DO NOT EDIT.
package task

import (
	"context"
	"fmt"

	"github.com/Xuanwo/navvy"
	"github.com/google/uuid"
	"github.com/qingstor/log"

	"github.com/qingstor/noah/pkg/schedule"
	"github.com/qingstor/noah/pkg/types"
)

var _ navvy.Pool
var _ types.Pool
var _ = uuid.New()

// BetweenStorageCheckTask will Do check for between storage task.
type BetweenStorageCheckTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
	types.DestinationObject
	types.SourceObject
}

// NewBetweenStorageCheck will create a BetweenStorageCheckTask struct and fetch inherited data from parent task.
func NewBetweenStorageCheck(task navvy.Task) *BetweenStorageCheckTask {
	t := &BetweenStorageCheckTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *BetweenStorageCheckTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task BetweenStorageCheck value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task BetweenStorageCheck value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task BetweenStorageCheck value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task BetweenStorageCheck value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *BetweenStorageCheckTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *BetweenStorageCheckTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *BetweenStorageCheckTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *BetweenStorageCheckTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *BetweenStorageCheckTask) String() string {
	return fmt.Sprintf("BetweenStorageCheckTask {DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewBetweenStorageCheckTask will create a BetweenStorageCheckTask which meets navvy.Task.
func NewBetweenStorageCheckTask(task navvy.Task) navvy.Task {
	return NewBetweenStorageCheck(task)
}

// CopyDirTask will copy a directory recursively between two storager.
type CopyDirTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.CheckTasks
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
	types.HandleObjCallback
}

// NewCopyDir will create a CopyDirTask struct and fetch inherited data from parent task.
func NewCopyDir(task navvy.Task) *CopyDirTask {
	t := &CopyDirTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyDirTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task CopyDir value CheckMD5 is invalid"))
	}
	if !t.ValidateCheckTasks() {
		panic(fmt.Errorf("Task CopyDir value CheckTasks is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyDir value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyDir value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyDir value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyDir value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyDirTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadCheckTasks(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopyDirTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *CopyDirTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyDirTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyDirTask) String() string {
	return fmt.Sprintf("CopyDirTask {CheckMD5: %v, CheckTasks: %v, DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetCheckMD5(), t.GetCheckTasks(), t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewCopyDirTask will create a CopyDirTask which meets navvy.Task.
func NewCopyDirTask(task navvy.Task) navvy.Task {
	return NewCopyDir(task)
}

// CopyFileTask will copy a file between two storager.
type CopyFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.CheckTasks
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
	types.HandleObjCallback
}

// NewCopyFile will create a CopyFileTask struct and fetch inherited data from parent task.
func NewCopyFile(task navvy.Task) *CopyFileTask {
	t := &CopyFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyFileTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task CopyFile value CheckMD5 is invalid"))
	}
	if !t.ValidateCheckTasks() {
		panic(fmt.Errorf("Task CopyFile value CheckTasks is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadCheckTasks(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopyFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *CopyFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyFileTask) String() string {
	return fmt.Sprintf("CopyFileTask {CheckMD5: %v, CheckTasks: %v, DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetCheckMD5(), t.GetCheckTasks(), t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewCopyFileTask will create a CopyFileTask which meets navvy.Task.
func NewCopyFileTask(task navvy.Task) navvy.Task {
	return NewCopyFile(task)
}

// CopyLargeFileTask will copy a large file between two storager.
type CopyLargeFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage
	types.TotalSize

	// Output value
	types.Offset
	types.PartSize
	types.Segment
}

// NewCopyLargeFile will create a CopyLargeFileTask struct and fetch inherited data from parent task.
func NewCopyLargeFile(task navvy.Task) *CopyLargeFileTask {
	t := &CopyLargeFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyLargeFileTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task CopyLargeFile value CheckMD5 is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyLargeFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyLargeFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyLargeFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyLargeFile value SourceStorage is invalid"))
	}
	if !t.ValidateTotalSize() {
		panic(fmt.Errorf("Task CopyLargeFile value TotalSize is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyLargeFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	types.LoadTotalSize(task, t)
}

// Run implement navvy.Task
func (t *CopyLargeFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *CopyLargeFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyLargeFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyLargeFileTask) String() string {
	return fmt.Sprintf("CopyLargeFileTask {CheckMD5: %v, DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v, TotalSize: %v}", t.GetCheckMD5(), t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage(), t.GetTotalSize())
}

// NewCopyLargeFileTask will create a CopyLargeFileTask which meets navvy.Task.
func NewCopyLargeFileTask(task navvy.Task) navvy.Task {
	return NewCopyLargeFile(task)
}

// CopyPartialFileTask will copy a partial file to between two storager.
type CopyPartialFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.DestinationPath
	types.DestinationStorage
	types.Index
	types.Offset
	types.PartSize
	types.Segment
	types.SourcePath
	types.SourceStorage
	types.TotalSize

	// Output value
	types.Done
	types.Size
}

// NewCopyPartialFile will create a CopyPartialFileTask struct and fetch inherited data from parent task.
func NewCopyPartialFile(task navvy.Task) *CopyPartialFileTask {
	t := &CopyPartialFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyPartialFileTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task CopyPartialFile value CheckMD5 is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyPartialFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyPartialFile value DestinationStorage is invalid"))
	}
	if !t.ValidateIndex() {
		panic(fmt.Errorf("Task CopyPartialFile value Index is invalid"))
	}
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task CopyPartialFile value Offset is invalid"))
	}
	if !t.ValidatePartSize() {
		panic(fmt.Errorf("Task CopyPartialFile value PartSize is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task CopyPartialFile value Segment is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyPartialFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyPartialFile value SourceStorage is invalid"))
	}
	if !t.ValidateTotalSize() {
		panic(fmt.Errorf("Task CopyPartialFile value TotalSize is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyPartialFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadIndex(task, t)
	types.LoadOffset(task, t)
	types.LoadPartSize(task, t)
	types.LoadSegment(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	types.LoadTotalSize(task, t)
}

// Run implement navvy.Task
func (t *CopyPartialFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *CopyPartialFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyPartialFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyPartialFileTask) String() string {
	return fmt.Sprintf("CopyPartialFileTask {CheckMD5: %v, DestinationPath: %v, DestinationStorage: %v, Index: %v, Offset: %v, PartSize: %v, Segment: %v, SourcePath: %v, SourceStorage: %v, TotalSize: %v}", t.GetCheckMD5(), t.GetDestinationPath(), t.GetDestinationStorage(), t.GetIndex(), t.GetOffset(), t.GetPartSize(), t.GetSegment(), t.GetSourcePath(), t.GetSourceStorage(), t.GetTotalSize())
}

// NewCopyPartialFileTask will create a CopyPartialFileTask which meets navvy.Task.
func NewCopyPartialFileTask(task navvy.Task) navvy.Task {
	return NewCopyPartialFile(task)
}

// CopyPartialStreamTask will copy a partial stream between two storager.
type CopyPartialStreamTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.DestinationPath
	types.DestinationStorage
	types.Index
	types.PartSize
	types.Segment
	types.SourcePath
	types.SourceStorage

	// Output value
	types.Content
	types.Done
	types.Offset
	types.Size
}

// NewCopyPartialStream will create a CopyPartialStreamTask struct and fetch inherited data from parent task.
func NewCopyPartialStream(task navvy.Task) *CopyPartialStreamTask {
	t := &CopyPartialStreamTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyPartialStreamTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task CopyPartialStream value CheckMD5 is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyPartialStream value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyPartialStream value DestinationStorage is invalid"))
	}
	if !t.ValidateIndex() {
		panic(fmt.Errorf("Task CopyPartialStream value Index is invalid"))
	}
	if !t.ValidatePartSize() {
		panic(fmt.Errorf("Task CopyPartialStream value PartSize is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task CopyPartialStream value Segment is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyPartialStream value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyPartialStream value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyPartialStreamTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadIndex(task, t)
	types.LoadPartSize(task, t)
	types.LoadSegment(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopyPartialStreamTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *CopyPartialStreamTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyPartialStreamTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyPartialStreamTask) String() string {
	return fmt.Sprintf("CopyPartialStreamTask {CheckMD5: %v, DestinationPath: %v, DestinationStorage: %v, Index: %v, PartSize: %v, Segment: %v, SourcePath: %v, SourceStorage: %v}", t.GetCheckMD5(), t.GetDestinationPath(), t.GetDestinationStorage(), t.GetIndex(), t.GetPartSize(), t.GetSegment(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewCopyPartialStreamTask will create a CopyPartialStreamTask which meets navvy.Task.
func NewCopyPartialStreamTask(task navvy.Task) navvy.Task {
	return NewCopyPartialStream(task)
}

// CopySingleFileTask will execute a file copy operation between two storager.
type CopySingleFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.MD5Sum
	types.Size
	types.SourcePath
	types.SourceStorage

	// Output value
}

// NewCopySingleFile will create a CopySingleFileTask struct and fetch inherited data from parent task.
func NewCopySingleFile(task navvy.Task) *CopySingleFileTask {
	t := &CopySingleFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopySingleFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopySingleFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopySingleFile value DestinationStorage is invalid"))
	}
	if !t.ValidateMD5Sum() {
		panic(fmt.Errorf("Task CopySingleFile value MD5Sum is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task CopySingleFile value Size is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopySingleFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopySingleFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopySingleFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadMD5Sum(task, t)
	types.LoadSize(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopySingleFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *CopySingleFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopySingleFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopySingleFileTask) String() string {
	return fmt.Sprintf("CopySingleFileTask {DestinationPath: %v, DestinationStorage: %v, MD5Sum: %v, Size: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetMD5Sum(), t.GetSize(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewCopySingleFileTask will create a CopySingleFileTask which meets navvy.Task.
func NewCopySingleFileTask(task navvy.Task) navvy.Task {
	return NewCopySingleFile(task)
}

// CopySmallFileTask will copy a small file between two storager.
type CopySmallFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.DestinationPath
	types.DestinationStorage
	types.Size
	types.SourcePath
	types.SourceStorage

	// Output value
	types.MD5Sum
}

// NewCopySmallFile will create a CopySmallFileTask struct and fetch inherited data from parent task.
func NewCopySmallFile(task navvy.Task) *CopySmallFileTask {
	t := &CopySmallFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopySmallFileTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task CopySmallFile value CheckMD5 is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopySmallFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopySmallFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task CopySmallFile value Size is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopySmallFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopySmallFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopySmallFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSize(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopySmallFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *CopySmallFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopySmallFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopySmallFileTask) String() string {
	return fmt.Sprintf("CopySmallFileTask {CheckMD5: %v, DestinationPath: %v, DestinationStorage: %v, Size: %v, SourcePath: %v, SourceStorage: %v}", t.GetCheckMD5(), t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSize(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewCopySmallFileTask will create a CopySmallFileTask which meets navvy.Task.
func NewCopySmallFileTask(task navvy.Task) navvy.Task {
	return NewCopySmallFile(task)
}

// CopyStreamTask will copy a stream between two storager.
type CopyStreamTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
	types.BytesPool
	types.PartSize
	types.Segment
}

// NewCopyStream will create a CopyStreamTask struct and fetch inherited data from parent task.
func NewCopyStream(task navvy.Task) *CopyStreamTask {
	t := &CopyStreamTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyStreamTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task CopyStream value CheckMD5 is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyStream value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyStream value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyStream value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyStream value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyStreamTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopyStreamTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *CopyStreamTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyStreamTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyStreamTask) String() string {
	return fmt.Sprintf("CopyStreamTask {CheckMD5: %v, DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetCheckMD5(), t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewCopyStreamTask will create a CopyStreamTask which meets navvy.Task.
func NewCopyStreamTask(task navvy.Task) navvy.Task {
	return NewCopyStream(task)
}

// CreateStorageTask will create a storage.
type CreateStorageTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Service

	// Output value
	types.StorageName
	types.Zone
}

// NewCreateStorage will create a CreateStorageTask struct and fetch inherited data from parent task.
func NewCreateStorage(task navvy.Task) *CreateStorageTask {
	t := &CreateStorageTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CreateStorageTask) validateInput() {
	if !t.ValidateService() {
		panic(fmt.Errorf("Task CreateStorage value Service is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CreateStorageTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadService(task, t)
}

// Run implement navvy.Task
func (t *CreateStorageTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *CreateStorageTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *CreateStorageTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CreateStorageTask) String() string {
	return fmt.Sprintf("CreateStorageTask {Service: %v}", t.GetService())
}

// NewCreateStorageTask will create a CreateStorageTask which meets navvy.Task.
func NewCreateStorageTask(task navvy.Task) navvy.Task {
	return NewCreateStorage(task)
}

// DeleteDirTask will will delete a dir recursively.
type DeleteDirTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Path
	types.Storage

	// Output value
	types.HandleObjCallback
}

// NewDeleteDir will create a DeleteDirTask struct and fetch inherited data from parent task.
func NewDeleteDir(task navvy.Task) *DeleteDirTask {
	t := &DeleteDirTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteDirTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task DeleteDir value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task DeleteDir value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteDirTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *DeleteDirTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *DeleteDirTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteDirTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeleteDirTask) String() string {
	return fmt.Sprintf("DeleteDirTask {Path: %v, Storage: %v}", t.GetPath(), t.GetStorage())
}

// NewDeleteDirTask will create a DeleteDirTask which meets navvy.Task.
func NewDeleteDirTask(task navvy.Task) navvy.Task {
	return NewDeleteDir(task)
}

// DeleteFileTask will will delete a file from storage.
type DeleteFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Path
	types.Storage

	// Output value
	types.HandleObjCallback
}

// NewDeleteFile will create a DeleteFileTask struct and fetch inherited data from parent task.
func NewDeleteFile(task navvy.Task) *DeleteFileTask {
	t := &DeleteFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteFileTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task DeleteFile value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task DeleteFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *DeleteFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *DeleteFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeleteFileTask) String() string {
	return fmt.Sprintf("DeleteFileTask {Path: %v, Storage: %v}", t.GetPath(), t.GetStorage())
}

// NewDeleteFileTask will create a DeleteFileTask which meets navvy.Task.
func NewDeleteFileTask(task navvy.Task) navvy.Task {
	return NewDeleteFile(task)
}

// DeletePrefixTask will will delete objects with given prefix from storage.
type DeletePrefixTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Path
	types.Storage

	// Output value
	types.HandleObjCallback
}

// NewDeletePrefix will create a DeletePrefixTask struct and fetch inherited data from parent task.
func NewDeletePrefix(task navvy.Task) *DeletePrefixTask {
	t := &DeletePrefixTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeletePrefixTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task DeletePrefix value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task DeletePrefix value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeletePrefixTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *DeletePrefixTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *DeletePrefixTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeletePrefixTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeletePrefixTask) String() string {
	return fmt.Sprintf("DeletePrefixTask {Path: %v, Storage: %v}", t.GetPath(), t.GetStorage())
}

// NewDeletePrefixTask will create a DeletePrefixTask which meets navvy.Task.
func NewDeletePrefixTask(task navvy.Task) navvy.Task {
	return NewDeletePrefix(task)
}

// DeleteSegmentTask will delete all segments with a given path.
type DeleteSegmentTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.PrefixSegmentsLister
	types.Segment

	// Output value
	types.HandleSegmentCallback
}

// NewDeleteSegment will create a DeleteSegmentTask struct and fetch inherited data from parent task.
func NewDeleteSegment(task navvy.Task) *DeleteSegmentTask {
	t := &DeleteSegmentTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteSegmentTask) validateInput() {
	if !t.ValidatePrefixSegmentsLister() {
		panic(fmt.Errorf("Task DeleteSegment value PrefixSegmentsLister is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task DeleteSegment value Segment is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteSegmentTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPrefixSegmentsLister(task, t)
	types.LoadSegment(task, t)
}

// Run implement navvy.Task
func (t *DeleteSegmentTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *DeleteSegmentTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteSegmentTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeleteSegmentTask) String() string {
	return fmt.Sprintf("DeleteSegmentTask {PrefixSegmentsLister: %v, Segment: %v}", t.GetPrefixSegmentsLister(), t.GetSegment())
}

// NewDeleteSegmentTask will create a DeleteSegmentTask which meets navvy.Task.
func NewDeleteSegmentTask(task navvy.Task) navvy.Task {
	return NewDeleteSegment(task)
}

// DeleteStorageTask will delete a storage.
type DeleteStorageTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Force
	types.Service
	types.StorageName
	types.Zone

	// Output value
	types.HandleObjCallback
	types.HandleSegmentCallback
}

// NewDeleteStorage will create a DeleteStorageTask struct and fetch inherited data from parent task.
func NewDeleteStorage(task navvy.Task) *DeleteStorageTask {
	t := &DeleteStorageTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteStorageTask) validateInput() {
	if !t.ValidateForce() {
		panic(fmt.Errorf("Task DeleteStorage value Force is invalid"))
	}
	if !t.ValidateService() {
		panic(fmt.Errorf("Task DeleteStorage value Service is invalid"))
	}
	if !t.ValidateStorageName() {
		panic(fmt.Errorf("Task DeleteStorage value StorageName is invalid"))
	}
	if !t.ValidateZone() {
		panic(fmt.Errorf("Task DeleteStorage value Zone is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteStorageTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadForce(task, t)
	types.LoadService(task, t)
	types.LoadStorageName(task, t)
	types.LoadZone(task, t)
}

// Run implement navvy.Task
func (t *DeleteStorageTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *DeleteStorageTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteStorageTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeleteStorageTask) String() string {
	return fmt.Sprintf("DeleteStorageTask {Force: %v, Service: %v, StorageName: %v, Zone: %v}", t.GetForce(), t.GetService(), t.GetStorageName(), t.GetZone())
}

// NewDeleteStorageTask will create a DeleteStorageTask which meets navvy.Task.
func NewDeleteStorageTask(task navvy.Task) navvy.Task {
	return NewDeleteStorage(task)
}

// InitSegmentStreamTask will init a partial stream between two storager.
type InitSegmentStreamTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.BytesPool
	types.PartSize
	types.SourcePath
	types.SourceStorage

	// Output value
	types.Content
	types.Done
	types.Size
}

// NewInitSegmentStream will create a InitSegmentStreamTask struct and fetch inherited data from parent task.
func NewInitSegmentStream(task navvy.Task) *InitSegmentStreamTask {
	t := &InitSegmentStreamTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *InitSegmentStreamTask) validateInput() {
	if !t.ValidateBytesPool() {
		panic(fmt.Errorf("Task InitSegmentStream value BytesPool is invalid"))
	}
	if !t.ValidatePartSize() {
		panic(fmt.Errorf("Task InitSegmentStream value PartSize is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task InitSegmentStream value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task InitSegmentStream value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *InitSegmentStreamTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadBytesPool(task, t)
	types.LoadPartSize(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *InitSegmentStreamTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *InitSegmentStreamTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *InitSegmentStreamTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *InitSegmentStreamTask) String() string {
	return fmt.Sprintf("InitSegmentStreamTask {BytesPool: %v, PartSize: %v, SourcePath: %v, SourceStorage: %v}", t.GetBytesPool(), t.GetPartSize(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewInitSegmentStreamTask will create a InitSegmentStreamTask which meets navvy.Task.
func NewInitSegmentStreamTask(task navvy.Task) navvy.Task {
	return NewInitSegmentStream(task)
}

// IsDestinationObjectExistTask will .
type IsDestinationObjectExistTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.DestinationObject

	// Output value
	types.Result
}

// NewIsDestinationObjectExist will create a IsDestinationObjectExistTask struct and fetch inherited data from parent task.
func NewIsDestinationObjectExist(task navvy.Task) *IsDestinationObjectExistTask {
	t := &IsDestinationObjectExistTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IsDestinationObjectExistTask) validateInput() {
	if !t.ValidateDestinationObject() {
		panic(fmt.Errorf("Task IsDestinationObjectExist value DestinationObject is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IsDestinationObjectExistTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationObject(task, t)
}

// Run implement navvy.Task
func (t *IsDestinationObjectExistTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *IsDestinationObjectExistTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *IsDestinationObjectExistTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *IsDestinationObjectExistTask) String() string {
	return fmt.Sprintf("IsDestinationObjectExistTask {DestinationObject: %v}", t.GetDestinationObject())
}

// NewIsDestinationObjectExistTask will create a IsDestinationObjectExistTask which meets navvy.Task.
func NewIsDestinationObjectExistTask(task navvy.Task) navvy.Task {
	return NewIsDestinationObjectExist(task)
}

// IsDestinationObjectNotExistTask will .
type IsDestinationObjectNotExistTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.DestinationObject

	// Output value
	types.Result
}

// NewIsDestinationObjectNotExist will create a IsDestinationObjectNotExistTask struct and fetch inherited data from parent task.
func NewIsDestinationObjectNotExist(task navvy.Task) *IsDestinationObjectNotExistTask {
	t := &IsDestinationObjectNotExistTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IsDestinationObjectNotExistTask) validateInput() {
	if !t.ValidateDestinationObject() {
		panic(fmt.Errorf("Task IsDestinationObjectNotExist value DestinationObject is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IsDestinationObjectNotExistTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationObject(task, t)
}

// Run implement navvy.Task
func (t *IsDestinationObjectNotExistTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *IsDestinationObjectNotExistTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *IsDestinationObjectNotExistTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *IsDestinationObjectNotExistTask) String() string {
	return fmt.Sprintf("IsDestinationObjectNotExistTask {DestinationObject: %v}", t.GetDestinationObject())
}

// NewIsDestinationObjectNotExistTask will create a IsDestinationObjectNotExistTask which meets navvy.Task.
func NewIsDestinationObjectNotExistTask(task navvy.Task) navvy.Task {
	return NewIsDestinationObjectNotExist(task)
}

// IsSizeEqualTask will .
type IsSizeEqualTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.DestinationObject
	types.SourceObject

	// Output value
	types.Result
}

// NewIsSizeEqual will create a IsSizeEqualTask struct and fetch inherited data from parent task.
func NewIsSizeEqual(task navvy.Task) *IsSizeEqualTask {
	t := &IsSizeEqualTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IsSizeEqualTask) validateInput() {
	if !t.ValidateDestinationObject() {
		panic(fmt.Errorf("Task IsSizeEqual value DestinationObject is invalid"))
	}
	if !t.ValidateSourceObject() {
		panic(fmt.Errorf("Task IsSizeEqual value SourceObject is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IsSizeEqualTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationObject(task, t)
	types.LoadSourceObject(task, t)
}

// Run implement navvy.Task
func (t *IsSizeEqualTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *IsSizeEqualTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *IsSizeEqualTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *IsSizeEqualTask) String() string {
	return fmt.Sprintf("IsSizeEqualTask {DestinationObject: %v, SourceObject: %v}", t.GetDestinationObject(), t.GetSourceObject())
}

// NewIsSizeEqualTask will create a IsSizeEqualTask which meets navvy.Task.
func NewIsSizeEqualTask(task navvy.Task) navvy.Task {
	return NewIsSizeEqual(task)
}

// IsUpdateAtGreaterTask will .
type IsUpdateAtGreaterTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.DestinationObject
	types.SourceObject

	// Output value
	types.Result
}

// NewIsUpdateAtGreater will create a IsUpdateAtGreaterTask struct and fetch inherited data from parent task.
func NewIsUpdateAtGreater(task navvy.Task) *IsUpdateAtGreaterTask {
	t := &IsUpdateAtGreaterTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IsUpdateAtGreaterTask) validateInput() {
	if !t.ValidateDestinationObject() {
		panic(fmt.Errorf("Task IsUpdateAtGreater value DestinationObject is invalid"))
	}
	if !t.ValidateSourceObject() {
		panic(fmt.Errorf("Task IsUpdateAtGreater value SourceObject is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IsUpdateAtGreaterTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationObject(task, t)
	types.LoadSourceObject(task, t)
}

// Run implement navvy.Task
func (t *IsUpdateAtGreaterTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *IsUpdateAtGreaterTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *IsUpdateAtGreaterTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *IsUpdateAtGreaterTask) String() string {
	return fmt.Sprintf("IsUpdateAtGreaterTask {DestinationObject: %v, SourceObject: %v}", t.GetDestinationObject(), t.GetSourceObject())
}

// NewIsUpdateAtGreaterTask will create a IsUpdateAtGreaterTask which meets navvy.Task.
func NewIsUpdateAtGreaterTask(task navvy.Task) navvy.Task {
	return NewIsUpdateAtGreater(task)
}

// ListDirTask will list dirs.
type ListDirTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.DirFunc
	types.DirLister
	types.FileFunc
	types.Path

	// Output value
}

// NewListDir will create a ListDirTask struct and fetch inherited data from parent task.
func NewListDir(task navvy.Task) *ListDirTask {
	t := &ListDirTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ListDirTask) validateInput() {
	if !t.ValidateDirFunc() {
		panic(fmt.Errorf("Task ListDir value DirFunc is invalid"))
	}
	if !t.ValidateDirLister() {
		panic(fmt.Errorf("Task ListDir value DirLister is invalid"))
	}
	if !t.ValidateFileFunc() {
		panic(fmt.Errorf("Task ListDir value FileFunc is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ListDir value Path is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ListDirTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDirFunc(task, t)
	types.LoadDirLister(task, t)
	types.LoadFileFunc(task, t)
	types.LoadPath(task, t)
}

// Run implement navvy.Task
func (t *ListDirTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *ListDirTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *ListDirTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ListDirTask) String() string {
	return fmt.Sprintf("ListDirTask {DirLister: %v, Path: %v}", t.GetDirLister(), t.GetPath())
}

// NewListDirTask will create a ListDirTask which meets navvy.Task.
func NewListDirTask(task navvy.Task) navvy.Task {
	return NewListDir(task)
}

// ListPrefixTask will list prefix.
type ListPrefixTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.ObjectFunc
	types.Path
	types.PrefixLister

	// Output value
}

// NewListPrefix will create a ListPrefixTask struct and fetch inherited data from parent task.
func NewListPrefix(task navvy.Task) *ListPrefixTask {
	t := &ListPrefixTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ListPrefixTask) validateInput() {
	if !t.ValidateObjectFunc() {
		panic(fmt.Errorf("Task ListPrefix value ObjectFunc is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ListPrefix value Path is invalid"))
	}
	if !t.ValidatePrefixLister() {
		panic(fmt.Errorf("Task ListPrefix value PrefixLister is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ListPrefixTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadObjectFunc(task, t)
	types.LoadPath(task, t)
	types.LoadPrefixLister(task, t)
}

// Run implement navvy.Task
func (t *ListPrefixTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *ListPrefixTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *ListPrefixTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ListPrefixTask) String() string {
	return fmt.Sprintf("ListPrefixTask {Path: %v, PrefixLister: %v}", t.GetPath(), t.GetPrefixLister())
}

// NewListPrefixTask will create a ListPrefixTask which meets navvy.Task.
func NewListPrefixTask(task navvy.Task) navvy.Task {
	return NewListPrefix(task)
}

// ListSegmentTask will list segments.
type ListSegmentTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Path
	types.PrefixSegmentsLister
	types.SegmentFunc

	// Output value
}

// NewListSegment will create a ListSegmentTask struct and fetch inherited data from parent task.
func NewListSegment(task navvy.Task) *ListSegmentTask {
	t := &ListSegmentTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ListSegmentTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ListSegment value Path is invalid"))
	}
	if !t.ValidatePrefixSegmentsLister() {
		panic(fmt.Errorf("Task ListSegment value PrefixSegmentsLister is invalid"))
	}
	if !t.ValidateSegmentFunc() {
		panic(fmt.Errorf("Task ListSegment value SegmentFunc is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ListSegmentTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadPrefixSegmentsLister(task, t)
	types.LoadSegmentFunc(task, t)
}

// Run implement navvy.Task
func (t *ListSegmentTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *ListSegmentTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *ListSegmentTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ListSegmentTask) String() string {
	return fmt.Sprintf("ListSegmentTask {Path: %v, PrefixSegmentsLister: %v}", t.GetPath(), t.GetPrefixSegmentsLister())
}

// NewListSegmentTask will create a ListSegmentTask which meets navvy.Task.
func NewListSegmentTask(task navvy.Task) navvy.Task {
	return NewListSegment(task)
}

// ListStorageTask will send get request to get bucket list.
type ListStorageTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Service
	types.StoragerFunc
	types.Zone

	// Output value
}

// NewListStorage will create a ListStorageTask struct and fetch inherited data from parent task.
func NewListStorage(task navvy.Task) *ListStorageTask {
	t := &ListStorageTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ListStorageTask) validateInput() {
	if !t.ValidateService() {
		panic(fmt.Errorf("Task ListStorage value Service is invalid"))
	}
	if !t.ValidateStoragerFunc() {
		panic(fmt.Errorf("Task ListStorage value StoragerFunc is invalid"))
	}
	if !t.ValidateZone() {
		panic(fmt.Errorf("Task ListStorage value Zone is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ListStorageTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadService(task, t)
	types.LoadStoragerFunc(task, t)
	types.LoadZone(task, t)
}

// Run implement navvy.Task
func (t *ListStorageTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *ListStorageTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *ListStorageTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ListStorageTask) String() string {
	return fmt.Sprintf("ListStorageTask {Service: %v, Zone: %v}", t.GetService(), t.GetZone())
}

// NewListStorageTask will create a ListStorageTask which meets navvy.Task.
func NewListStorageTask(task navvy.Task) navvy.Task {
	return NewListStorage(task)
}

// MD5SumFileTask will get file's md5 sum.
type MD5SumFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Offset
	types.Path
	types.Size
	types.Storage

	// Output value
	types.MD5Sum
}

// NewMD5SumFile will create a MD5SumFileTask struct and fetch inherited data from parent task.
func NewMD5SumFile(task navvy.Task) *MD5SumFileTask {
	t := &MD5SumFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MD5SumFileTask) validateInput() {
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task MD5SumFile value Offset is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task MD5SumFile value Path is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task MD5SumFile value Size is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task MD5SumFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MD5SumFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadOffset(task, t)
	types.LoadPath(task, t)
	types.LoadSize(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *MD5SumFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *MD5SumFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *MD5SumFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *MD5SumFileTask) String() string {
	return fmt.Sprintf("MD5SumFileTask {Offset: %v, Path: %v, Size: %v, Storage: %v}", t.GetOffset(), t.GetPath(), t.GetSize(), t.GetStorage())
}

// NewMD5SumFileTask will create a MD5SumFileTask which meets navvy.Task.
func NewMD5SumFileTask(task navvy.Task) navvy.Task {
	return NewMD5SumFile(task)
}

// MD5SumStreamTask will get stream's md5 sum.
type MD5SumStreamTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Content

	// Output value
	types.MD5Sum
}

// NewMD5SumStream will create a MD5SumStreamTask struct and fetch inherited data from parent task.
func NewMD5SumStream(task navvy.Task) *MD5SumStreamTask {
	t := &MD5SumStreamTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MD5SumStreamTask) validateInput() {
	if !t.ValidateContent() {
		panic(fmt.Errorf("Task MD5SumStream value Content is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MD5SumStreamTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadContent(task, t)
}

// Run implement navvy.Task
func (t *MD5SumStreamTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *MD5SumStreamTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *MD5SumStreamTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *MD5SumStreamTask) String() string {
	return fmt.Sprintf("MD5SumStreamTask {Content: %v}", t.GetContent())
}

// NewMD5SumStreamTask will create a MD5SumStreamTask which meets navvy.Task.
func NewMD5SumStreamTask(task navvy.Task) navvy.Task {
	return NewMD5SumStream(task)
}

// MoveDirTask will move a directory recursively between two storager.
type MoveDirTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
	types.HandleObjCallback
}

// NewMoveDir will create a MoveDirTask struct and fetch inherited data from parent task.
func NewMoveDir(task navvy.Task) *MoveDirTask {
	t := &MoveDirTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MoveDirTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task MoveDir value CheckMD5 is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task MoveDir value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task MoveDir value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task MoveDir value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task MoveDir value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MoveDirTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *MoveDirTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *MoveDirTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *MoveDirTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *MoveDirTask) String() string {
	return fmt.Sprintf("MoveDirTask {CheckMD5: %v, DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetCheckMD5(), t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewMoveDirTask will create a MoveDirTask which meets navvy.Task.
func NewMoveDirTask(task navvy.Task) navvy.Task {
	return NewMoveDir(task)
}

// MoveFileTask will move a file between two storager.
type MoveFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
	types.HandleObjCallback
}

// NewMoveFile will create a MoveFileTask struct and fetch inherited data from parent task.
func NewMoveFile(task navvy.Task) *MoveFileTask {
	t := &MoveFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MoveFileTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task MoveFile value CheckMD5 is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task MoveFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task MoveFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task MoveFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task MoveFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MoveFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *MoveFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *MoveFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *MoveFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *MoveFileTask) String() string {
	return fmt.Sprintf("MoveFileTask {CheckMD5: %v, DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetCheckMD5(), t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewMoveFileTask will create a MoveFileTask which meets navvy.Task.
func NewMoveFileTask(task navvy.Task) navvy.Task {
	return NewMoveFile(task)
}

// ReachFileTask will will reach a remote object and return the signed url.
type ReachFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Expire
	types.Path
	types.Reacher

	// Output value
	types.URL
}

// NewReachFile will create a ReachFileTask struct and fetch inherited data from parent task.
func NewReachFile(task navvy.Task) *ReachFileTask {
	t := &ReachFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ReachFileTask) validateInput() {
	if !t.ValidateExpire() {
		panic(fmt.Errorf("Task ReachFile value Expire is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ReachFile value Path is invalid"))
	}
	if !t.ValidateReacher() {
		panic(fmt.Errorf("Task ReachFile value Reacher is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ReachFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadExpire(task, t)
	types.LoadPath(task, t)
	types.LoadReacher(task, t)
}

// Run implement navvy.Task
func (t *ReachFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *ReachFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *ReachFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ReachFileTask) String() string {
	return fmt.Sprintf("ReachFileTask {Expire: %v, Path: %v, Reacher: %v}", t.GetExpire(), t.GetPath(), t.GetReacher())
}

// NewReachFileTask will create a ReachFileTask which meets navvy.Task.
func NewReachFileTask(task navvy.Task) navvy.Task {
	return NewReachFile(task)
}

// SegmentCompleteTask will complete a segment.
type SegmentCompleteTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.IndexSegmenter
	types.Path
	types.Segment

	// Output value
}

// NewSegmentComplete will create a SegmentCompleteTask struct and fetch inherited data from parent task.
func NewSegmentComplete(task navvy.Task) *SegmentCompleteTask {
	t := &SegmentCompleteTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentCompleteTask) validateInput() {
	if !t.ValidateIndexSegmenter() {
		panic(fmt.Errorf("Task SegmentComplete value IndexSegmenter is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task SegmentComplete value Path is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task SegmentComplete value Segment is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentCompleteTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadIndexSegmenter(task, t)
	types.LoadPath(task, t)
	types.LoadSegment(task, t)
}

// Run implement navvy.Task
func (t *SegmentCompleteTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *SegmentCompleteTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentCompleteTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SegmentCompleteTask) String() string {
	return fmt.Sprintf("SegmentCompleteTask {IndexSegmenter: %v, Path: %v, Segment: %v}", t.GetIndexSegmenter(), t.GetPath(), t.GetSegment())
}

// NewSegmentCompleteTask will create a SegmentCompleteTask which meets navvy.Task.
func NewSegmentCompleteTask(task navvy.Task) navvy.Task {
	return NewSegmentComplete(task)
}

// SegmentFileCopyTask will copy a segment file.
type SegmentFileCopyTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.DestinationIndexSegmenter
	types.DestinationPath
	types.Index
	types.MD5Sum
	types.Offset
	types.Segment
	types.Size
	types.SourcePath
	types.SourceStorage

	// Output value
}

// NewSegmentFileCopy will create a SegmentFileCopyTask struct and fetch inherited data from parent task.
func NewSegmentFileCopy(task navvy.Task) *SegmentFileCopyTask {
	t := &SegmentFileCopyTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentFileCopyTask) validateInput() {
	if !t.ValidateDestinationIndexSegmenter() {
		panic(fmt.Errorf("Task SegmentFileCopy value DestinationIndexSegmenter is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task SegmentFileCopy value DestinationPath is invalid"))
	}
	if !t.ValidateIndex() {
		panic(fmt.Errorf("Task SegmentFileCopy value Index is invalid"))
	}
	if !t.ValidateMD5Sum() {
		panic(fmt.Errorf("Task SegmentFileCopy value MD5Sum is invalid"))
	}
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task SegmentFileCopy value Offset is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task SegmentFileCopy value Segment is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task SegmentFileCopy value Size is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task SegmentFileCopy value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task SegmentFileCopy value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentFileCopyTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationIndexSegmenter(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadIndex(task, t)
	types.LoadMD5Sum(task, t)
	types.LoadOffset(task, t)
	types.LoadSegment(task, t)
	types.LoadSize(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *SegmentFileCopyTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *SegmentFileCopyTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentFileCopyTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SegmentFileCopyTask) String() string {
	return fmt.Sprintf("SegmentFileCopyTask {DestinationIndexSegmenter: %v, DestinationPath: %v, Index: %v, MD5Sum: %v, Offset: %v, Segment: %v, Size: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationIndexSegmenter(), t.GetDestinationPath(), t.GetIndex(), t.GetMD5Sum(), t.GetOffset(), t.GetSegment(), t.GetSize(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewSegmentFileCopyTask will create a SegmentFileCopyTask which meets navvy.Task.
func NewSegmentFileCopyTask(task navvy.Task) navvy.Task {
	return NewSegmentFileCopy(task)
}

// SegmentInitTask will init a segment upload.
type SegmentInitTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.IndexSegmenter
	types.PartSize
	types.Path

	// Output value
	types.Segment
}

// NewSegmentInit will create a SegmentInitTask struct and fetch inherited data from parent task.
func NewSegmentInit(task navvy.Task) *SegmentInitTask {
	t := &SegmentInitTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentInitTask) validateInput() {
	if !t.ValidateIndexSegmenter() {
		panic(fmt.Errorf("Task SegmentInit value IndexSegmenter is invalid"))
	}
	if !t.ValidatePartSize() {
		panic(fmt.Errorf("Task SegmentInit value PartSize is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task SegmentInit value Path is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentInitTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadIndexSegmenter(task, t)
	types.LoadPartSize(task, t)
	types.LoadPath(task, t)
}

// Run implement navvy.Task
func (t *SegmentInitTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *SegmentInitTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentInitTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SegmentInitTask) String() string {
	return fmt.Sprintf("SegmentInitTask {IndexSegmenter: %v, PartSize: %v, Path: %v}", t.GetIndexSegmenter(), t.GetPartSize(), t.GetPath())
}

// NewSegmentInitTask will create a SegmentInitTask which meets navvy.Task.
func NewSegmentInitTask(task navvy.Task) navvy.Task {
	return NewSegmentInit(task)
}

// SegmentStreamCopyTask will copy a segment stream.
type SegmentStreamCopyTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Content
	types.DestinationIndexSegmenter
	types.DestinationPath
	types.Index
	types.MD5Sum
	types.Offset
	types.Segment
	types.Size

	// Output value
}

// NewSegmentStreamCopy will create a SegmentStreamCopyTask struct and fetch inherited data from parent task.
func NewSegmentStreamCopy(task navvy.Task) *SegmentStreamCopyTask {
	t := &SegmentStreamCopyTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentStreamCopyTask) validateInput() {
	if !t.ValidateContent() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Content is invalid"))
	}
	if !t.ValidateDestinationIndexSegmenter() {
		panic(fmt.Errorf("Task SegmentStreamCopy value DestinationIndexSegmenter is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task SegmentStreamCopy value DestinationPath is invalid"))
	}
	if !t.ValidateIndex() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Index is invalid"))
	}
	if !t.ValidateMD5Sum() {
		panic(fmt.Errorf("Task SegmentStreamCopy value MD5Sum is invalid"))
	}
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Offset is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Segment is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Size is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentStreamCopyTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadContent(task, t)
	types.LoadDestinationIndexSegmenter(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadIndex(task, t)
	types.LoadMD5Sum(task, t)
	types.LoadOffset(task, t)
	types.LoadSegment(task, t)
	types.LoadSize(task, t)
}

// Run implement navvy.Task
func (t *SegmentStreamCopyTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *SegmentStreamCopyTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentStreamCopyTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SegmentStreamCopyTask) String() string {
	return fmt.Sprintf("SegmentStreamCopyTask {Content: %v, DestinationIndexSegmenter: %v, DestinationPath: %v, Index: %v, MD5Sum: %v, Offset: %v, Segment: %v, Size: %v}", t.GetContent(), t.GetDestinationIndexSegmenter(), t.GetDestinationPath(), t.GetIndex(), t.GetMD5Sum(), t.GetOffset(), t.GetSegment(), t.GetSize())
}

// NewSegmentStreamCopyTask will create a SegmentStreamCopyTask which meets navvy.Task.
func NewSegmentStreamCopyTask(task navvy.Task) navvy.Task {
	return NewSegmentStreamCopy(task)
}

// StatFileTask will stat a remote object by request headObject.
type StatFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Path
	types.Storage

	// Output value
	types.Object
}

// NewStatFile will create a StatFileTask struct and fetch inherited data from parent task.
func NewStatFile(task navvy.Task) *StatFileTask {
	t := &StatFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *StatFileTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task StatFile value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task StatFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *StatFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *StatFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *StatFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *StatFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *StatFileTask) String() string {
	return fmt.Sprintf("StatFileTask {Path: %v, Storage: %v}", t.GetPath(), t.GetStorage())
}

// NewStatFileTask will create a StatFileTask which meets navvy.Task.
func NewStatFileTask(task navvy.Task) navvy.Task {
	return NewStatFile(task)
}

// StatStorageTask will stat a remote storage by Statistical.
type StatStorageTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Storage

	// Output value
	types.StorageInfo
}

// NewStatStorage will create a StatStorageTask struct and fetch inherited data from parent task.
func NewStatStorage(task navvy.Task) *StatStorageTask {
	t := &StatStorageTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *StatStorageTask) validateInput() {
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task StatStorage value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *StatStorageTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *StatStorageTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *StatStorageTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *StatStorageTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *StatStorageTask) String() string {
	return fmt.Sprintf("StatStorageTask {Storage: %v}", t.GetStorage())
}

// NewStatStorageTask will create a StatStorageTask which meets navvy.Task.
func NewStatStorageTask(task navvy.Task) navvy.Task {
	return NewStatStorage(task)
}

// SyncTask will sync directory between two storage.
type SyncTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.DestinationPath
	types.DestinationStorage
	types.DryRun
	types.DryRunFunc
	types.Existing
	types.IgnoreExisting
	types.Recursive
	types.SourcePath
	types.SourceStorage
	types.Update

	// Output value
	types.HandleObjCallback
}

// NewSync will create a SyncTask struct and fetch inherited data from parent task.
func NewSync(task navvy.Task) *SyncTask {
	t := &SyncTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SyncTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task Sync value CheckMD5 is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task Sync value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task Sync value DestinationStorage is invalid"))
	}
	if !t.ValidateDryRun() {
		panic(fmt.Errorf("Task Sync value DryRun is invalid"))
	}
	if !t.ValidateDryRunFunc() {
		panic(fmt.Errorf("Task Sync value DryRunFunc is invalid"))
	}
	if !t.ValidateExisting() {
		panic(fmt.Errorf("Task Sync value Existing is invalid"))
	}
	if !t.ValidateIgnoreExisting() {
		panic(fmt.Errorf("Task Sync value IgnoreExisting is invalid"))
	}
	if !t.ValidateRecursive() {
		panic(fmt.Errorf("Task Sync value Recursive is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task Sync value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task Sync value SourceStorage is invalid"))
	}
	if !t.ValidateUpdate() {
		panic(fmt.Errorf("Task Sync value Update is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SyncTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadDryRun(task, t)
	types.LoadDryRunFunc(task, t)
	types.LoadExisting(task, t)
	types.LoadIgnoreExisting(task, t)
	types.LoadRecursive(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	types.LoadUpdate(task, t)
}

// Run implement navvy.Task
func (t *SyncTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *SyncTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *SyncTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SyncTask) String() string {
	return fmt.Sprintf("SyncTask {CheckMD5: %v, DestinationPath: %v, DestinationStorage: %v, DryRun: %v, Existing: %v, IgnoreExisting: %v, Recursive: %v, SourcePath: %v, SourceStorage: %v, Update: %v}", t.GetCheckMD5(), t.GetDestinationPath(), t.GetDestinationStorage(), t.GetDryRun(), t.GetExisting(), t.GetIgnoreExisting(), t.GetRecursive(), t.GetSourcePath(), t.GetSourceStorage(), t.GetUpdate())
}

// NewSyncTask will create a SyncTask which meets navvy.Task.
func NewSyncTask(task navvy.Task) navvy.Task {
	return NewSync(task)
}
