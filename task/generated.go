// Code generated by go generate; DO NOT EDIT.
package task

import (
	"context"
	"fmt"
	"strings"

	"github.com/Xuanwo/navvy"
	"github.com/google/uuid"
	"github.com/qingstor/log"

	"github.com/qingstor/noah/pkg/schedule"
	"github.com/qingstor/noah/pkg/types"
)

var _ navvy.Pool
var _ types.Pool
var _ = uuid.New()

// BetweenStorageCheckTask will Do check for between storage task.
type BetweenStorageCheckTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
	types.DestinationObject
	types.SourceObject
}

// NewBetweenStorageCheck will create a BetweenStorageCheckTask struct and fetch inherited data from parent task.
func NewBetweenStorageCheck(task navvy.Task) *BetweenStorageCheckTask {
	t := &BetweenStorageCheckTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *BetweenStorageCheckTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task BetweenStorageCheck value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task BetweenStorageCheck value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task BetweenStorageCheck value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task BetweenStorageCheck value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *BetweenStorageCheckTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *BetweenStorageCheckTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *BetweenStorageCheckTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *BetweenStorageCheckTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *BetweenStorageCheckTask) String() string {
	s := make([]string, 0, 4)
	if t.ValidateDestinationPath() {
		s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	}
	if t.ValidateDestinationStorage() {
		s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	}
	if t.ValidateSourcePath() {
		s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	}
	if t.ValidateSourceStorage() {
		s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	}
	return fmt.Sprintf("BetweenStorageCheckTask {%s}", strings.Join(s, ", "))
}

// NewBetweenStorageCheckTask will create a BetweenStorageCheckTask which meets navvy.Task.
func NewBetweenStorageCheckTask(task navvy.Task) navvy.Task {
	return NewBetweenStorageCheck(task)
}

// CopyDirTask will copy a directory recursively between two storager.
type CopyDirTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.CheckTasks
	types.DestinationPath
	types.DestinationStorage
	types.PartThreshold
	types.SourcePath
	types.SourceStorage

	// Output value
	types.HandleObjCallback
	types.PartSize
}

// NewCopyDir will create a CopyDirTask struct and fetch inherited data from parent task.
func NewCopyDir(task navvy.Task) *CopyDirTask {
	t := &CopyDirTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyDirTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task CopyDir value CheckMD5 is invalid"))
	}
	if !t.ValidateCheckTasks() {
		panic(fmt.Errorf("Task CopyDir value CheckTasks is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyDir value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyDir value DestinationStorage is invalid"))
	}
	if !t.ValidatePartThreshold() {
		panic(fmt.Errorf("Task CopyDir value PartThreshold is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyDir value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyDir value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyDirTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadCheckTasks(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadPartThreshold(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopyDirTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *CopyDirTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyDirTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyDirTask) String() string {
	s := make([]string, 0, 7)
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidateCheckTasks() {
		s = append(s, fmt.Sprintf("CheckTasks: %s", t.CheckTasks.String()))
	}
	if t.ValidateDestinationPath() {
		s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	}
	if t.ValidateDestinationStorage() {
		s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	}
	if t.ValidatePartThreshold() {
		s = append(s, fmt.Sprintf("PartThreshold: %s", t.PartThreshold.String()))
	}
	if t.ValidateSourcePath() {
		s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	}
	if t.ValidateSourceStorage() {
		s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	}
	return fmt.Sprintf("CopyDirTask {%s}", strings.Join(s, ", "))
}

// NewCopyDirTask will create a CopyDirTask which meets navvy.Task.
func NewCopyDirTask(task navvy.Task) navvy.Task {
	return NewCopyDir(task)
}

// CopyFileTask will copy a file between two storager.
type CopyFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.CheckTasks
	types.DestinationPath
	types.DestinationStorage
	types.PartThreshold
	types.SourcePath
	types.SourceStorage

	// Output value
	types.HandleObjCallback
	types.PartSize
}

// NewCopyFile will create a CopyFileTask struct and fetch inherited data from parent task.
func NewCopyFile(task navvy.Task) *CopyFileTask {
	t := &CopyFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyFileTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task CopyFile value CheckMD5 is invalid"))
	}
	if !t.ValidateCheckTasks() {
		panic(fmt.Errorf("Task CopyFile value CheckTasks is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyFile value DestinationStorage is invalid"))
	}
	if !t.ValidatePartThreshold() {
		panic(fmt.Errorf("Task CopyFile value PartThreshold is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadCheckTasks(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadPartThreshold(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopyFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *CopyFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyFileTask) String() string {
	s := make([]string, 0, 7)
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidateCheckTasks() {
		s = append(s, fmt.Sprintf("CheckTasks: %s", t.CheckTasks.String()))
	}
	if t.ValidateDestinationPath() {
		s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	}
	if t.ValidateDestinationStorage() {
		s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	}
	if t.ValidatePartThreshold() {
		s = append(s, fmt.Sprintf("PartThreshold: %s", t.PartThreshold.String()))
	}
	if t.ValidateSourcePath() {
		s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	}
	if t.ValidateSourceStorage() {
		s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	}
	return fmt.Sprintf("CopyFileTask {%s}", strings.Join(s, ", "))
}

// NewCopyFileTask will create a CopyFileTask which meets navvy.Task.
func NewCopyFileTask(task navvy.Task) navvy.Task {
	return NewCopyFile(task)
}

// CopyLargeFileTask will copy a large file between two storager.
type CopyLargeFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage
	types.TotalSize

	// Output value
	types.Offset
	types.PartSize
	types.Segment
}

// NewCopyLargeFile will create a CopyLargeFileTask struct and fetch inherited data from parent task.
func NewCopyLargeFile(task navvy.Task) *CopyLargeFileTask {
	t := &CopyLargeFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyLargeFileTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task CopyLargeFile value CheckMD5 is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyLargeFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyLargeFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyLargeFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyLargeFile value SourceStorage is invalid"))
	}
	if !t.ValidateTotalSize() {
		panic(fmt.Errorf("Task CopyLargeFile value TotalSize is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyLargeFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	types.LoadTotalSize(task, t)
}

// Run implement navvy.Task
func (t *CopyLargeFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *CopyLargeFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyLargeFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyLargeFileTask) String() string {
	s := make([]string, 0, 6)
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidateDestinationPath() {
		s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	}
	if t.ValidateDestinationStorage() {
		s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	}
	if t.ValidateSourcePath() {
		s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	}
	if t.ValidateSourceStorage() {
		s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	}
	if t.ValidateTotalSize() {
		s = append(s, fmt.Sprintf("TotalSize: %s", t.TotalSize.String()))
	}
	return fmt.Sprintf("CopyLargeFileTask {%s}", strings.Join(s, ", "))
}

// NewCopyLargeFileTask will create a CopyLargeFileTask which meets navvy.Task.
func NewCopyLargeFileTask(task navvy.Task) navvy.Task {
	return NewCopyLargeFile(task)
}

// CopyPartialFileTask will copy a partial file to between two storager.
type CopyPartialFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.DestinationPath
	types.DestinationStorage
	types.Index
	types.Offset
	types.PartSize
	types.Segment
	types.SourcePath
	types.SourceStorage
	types.TotalSize

	// Output value
	types.Done
	types.Size
}

// NewCopyPartialFile will create a CopyPartialFileTask struct and fetch inherited data from parent task.
func NewCopyPartialFile(task navvy.Task) *CopyPartialFileTask {
	t := &CopyPartialFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyPartialFileTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task CopyPartialFile value CheckMD5 is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyPartialFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyPartialFile value DestinationStorage is invalid"))
	}
	if !t.ValidateIndex() {
		panic(fmt.Errorf("Task CopyPartialFile value Index is invalid"))
	}
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task CopyPartialFile value Offset is invalid"))
	}
	if !t.ValidatePartSize() {
		panic(fmt.Errorf("Task CopyPartialFile value PartSize is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task CopyPartialFile value Segment is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyPartialFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyPartialFile value SourceStorage is invalid"))
	}
	if !t.ValidateTotalSize() {
		panic(fmt.Errorf("Task CopyPartialFile value TotalSize is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyPartialFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadIndex(task, t)
	types.LoadOffset(task, t)
	types.LoadPartSize(task, t)
	types.LoadSegment(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	types.LoadTotalSize(task, t)
}

// Run implement navvy.Task
func (t *CopyPartialFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *CopyPartialFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyPartialFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyPartialFileTask) String() string {
	s := make([]string, 0, 10)
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidateDestinationPath() {
		s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	}
	if t.ValidateDestinationStorage() {
		s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	}
	if t.ValidateIndex() {
		s = append(s, fmt.Sprintf("Index: %s", t.Index.String()))
	}
	if t.ValidateOffset() {
		s = append(s, fmt.Sprintf("Offset: %s", t.Offset.String()))
	}
	if t.ValidatePartSize() {
		s = append(s, fmt.Sprintf("PartSize: %s", t.PartSize.String()))
	}
	if t.ValidateSegment() {
		s = append(s, fmt.Sprintf("Segment: %s", t.Segment.String()))
	}
	if t.ValidateSourcePath() {
		s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	}
	if t.ValidateSourceStorage() {
		s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	}
	if t.ValidateTotalSize() {
		s = append(s, fmt.Sprintf("TotalSize: %s", t.TotalSize.String()))
	}
	return fmt.Sprintf("CopyPartialFileTask {%s}", strings.Join(s, ", "))
}

// NewCopyPartialFileTask will create a CopyPartialFileTask which meets navvy.Task.
func NewCopyPartialFileTask(task navvy.Task) navvy.Task {
	return NewCopyPartialFile(task)
}

// CopyPartialStreamTask will copy a partial stream between two storager.
type CopyPartialStreamTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.DestinationPath
	types.DestinationStorage
	types.Index
	types.PartSize
	types.Segment
	types.SourcePath
	types.SourceStorage

	// Output value
	types.Content
	types.Done
	types.Offset
	types.Size
}

// NewCopyPartialStream will create a CopyPartialStreamTask struct and fetch inherited data from parent task.
func NewCopyPartialStream(task navvy.Task) *CopyPartialStreamTask {
	t := &CopyPartialStreamTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyPartialStreamTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task CopyPartialStream value CheckMD5 is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyPartialStream value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyPartialStream value DestinationStorage is invalid"))
	}
	if !t.ValidateIndex() {
		panic(fmt.Errorf("Task CopyPartialStream value Index is invalid"))
	}
	if !t.ValidatePartSize() {
		panic(fmt.Errorf("Task CopyPartialStream value PartSize is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task CopyPartialStream value Segment is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyPartialStream value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyPartialStream value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyPartialStreamTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadIndex(task, t)
	types.LoadPartSize(task, t)
	types.LoadSegment(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopyPartialStreamTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *CopyPartialStreamTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyPartialStreamTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyPartialStreamTask) String() string {
	s := make([]string, 0, 8)
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidateDestinationPath() {
		s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	}
	if t.ValidateDestinationStorage() {
		s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	}
	if t.ValidateIndex() {
		s = append(s, fmt.Sprintf("Index: %s", t.Index.String()))
	}
	if t.ValidatePartSize() {
		s = append(s, fmt.Sprintf("PartSize: %s", t.PartSize.String()))
	}
	if t.ValidateSegment() {
		s = append(s, fmt.Sprintf("Segment: %s", t.Segment.String()))
	}
	if t.ValidateSourcePath() {
		s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	}
	if t.ValidateSourceStorage() {
		s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	}
	return fmt.Sprintf("CopyPartialStreamTask {%s}", strings.Join(s, ", "))
}

// NewCopyPartialStreamTask will create a CopyPartialStreamTask which meets navvy.Task.
func NewCopyPartialStreamTask(task navvy.Task) navvy.Task {
	return NewCopyPartialStream(task)
}

// CopySingleFileTask will execute a file copy operation between two storager.
type CopySingleFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.MD5Sum
	types.Size
	types.SourcePath
	types.SourceStorage

	// Output value
}

// NewCopySingleFile will create a CopySingleFileTask struct and fetch inherited data from parent task.
func NewCopySingleFile(task navvy.Task) *CopySingleFileTask {
	t := &CopySingleFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopySingleFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopySingleFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopySingleFile value DestinationStorage is invalid"))
	}
	if !t.ValidateMD5Sum() {
		panic(fmt.Errorf("Task CopySingleFile value MD5Sum is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task CopySingleFile value Size is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopySingleFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopySingleFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopySingleFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadMD5Sum(task, t)
	types.LoadSize(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopySingleFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *CopySingleFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopySingleFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopySingleFileTask) String() string {
	s := make([]string, 0, 6)
	if t.ValidateDestinationPath() {
		s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	}
	if t.ValidateDestinationStorage() {
		s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	}
	if t.ValidateMD5Sum() {
		s = append(s, fmt.Sprintf("MD5Sum: %s", t.MD5Sum.String()))
	}
	if t.ValidateSize() {
		s = append(s, fmt.Sprintf("Size: %s", t.Size.String()))
	}
	if t.ValidateSourcePath() {
		s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	}
	if t.ValidateSourceStorage() {
		s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	}
	return fmt.Sprintf("CopySingleFileTask {%s}", strings.Join(s, ", "))
}

// NewCopySingleFileTask will create a CopySingleFileTask which meets navvy.Task.
func NewCopySingleFileTask(task navvy.Task) navvy.Task {
	return NewCopySingleFile(task)
}

// CopySmallFileTask will copy a small file between two storager.
type CopySmallFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.DestinationPath
	types.DestinationStorage
	types.Size
	types.SourcePath
	types.SourceStorage

	// Output value
	types.MD5Sum
}

// NewCopySmallFile will create a CopySmallFileTask struct and fetch inherited data from parent task.
func NewCopySmallFile(task navvy.Task) *CopySmallFileTask {
	t := &CopySmallFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopySmallFileTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task CopySmallFile value CheckMD5 is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopySmallFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopySmallFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task CopySmallFile value Size is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopySmallFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopySmallFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopySmallFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSize(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopySmallFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *CopySmallFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopySmallFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopySmallFileTask) String() string {
	s := make([]string, 0, 6)
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidateDestinationPath() {
		s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	}
	if t.ValidateDestinationStorage() {
		s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	}
	if t.ValidateSize() {
		s = append(s, fmt.Sprintf("Size: %s", t.Size.String()))
	}
	if t.ValidateSourcePath() {
		s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	}
	if t.ValidateSourceStorage() {
		s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	}
	return fmt.Sprintf("CopySmallFileTask {%s}", strings.Join(s, ", "))
}

// NewCopySmallFileTask will create a CopySmallFileTask which meets navvy.Task.
func NewCopySmallFileTask(task navvy.Task) navvy.Task {
	return NewCopySmallFile(task)
}

// CopyStreamTask will copy a stream between two storager.
type CopyStreamTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
	types.BytesPool
	types.PartSize
	types.Segment
}

// NewCopyStream will create a CopyStreamTask struct and fetch inherited data from parent task.
func NewCopyStream(task navvy.Task) *CopyStreamTask {
	t := &CopyStreamTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyStreamTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task CopyStream value CheckMD5 is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyStream value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyStream value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyStream value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyStream value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyStreamTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopyStreamTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *CopyStreamTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyStreamTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyStreamTask) String() string {
	s := make([]string, 0, 5)
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidateDestinationPath() {
		s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	}
	if t.ValidateDestinationStorage() {
		s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	}
	if t.ValidateSourcePath() {
		s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	}
	if t.ValidateSourceStorage() {
		s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	}
	return fmt.Sprintf("CopyStreamTask {%s}", strings.Join(s, ", "))
}

// NewCopyStreamTask will create a CopyStreamTask which meets navvy.Task.
func NewCopyStreamTask(task navvy.Task) navvy.Task {
	return NewCopyStream(task)
}

// CreateStorageTask will create a storage.
type CreateStorageTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Service

	// Output value
	types.StorageName
	types.Zone
}

// NewCreateStorage will create a CreateStorageTask struct and fetch inherited data from parent task.
func NewCreateStorage(task navvy.Task) *CreateStorageTask {
	t := &CreateStorageTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CreateStorageTask) validateInput() {
	if !t.ValidateService() {
		panic(fmt.Errorf("Task CreateStorage value Service is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CreateStorageTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadService(task, t)
}

// Run implement navvy.Task
func (t *CreateStorageTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *CreateStorageTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *CreateStorageTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CreateStorageTask) String() string {
	s := make([]string, 0, 1)
	if t.ValidateService() {
		s = append(s, fmt.Sprintf("Service: %s", t.Service.String()))
	}
	return fmt.Sprintf("CreateStorageTask {%s}", strings.Join(s, ", "))
}

// NewCreateStorageTask will create a CreateStorageTask which meets navvy.Task.
func NewCreateStorageTask(task navvy.Task) navvy.Task {
	return NewCreateStorage(task)
}

// DeleteDirTask will will delete a dir recursively.
type DeleteDirTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Path
	types.Storage

	// Output value
	types.HandleObjCallback
}

// NewDeleteDir will create a DeleteDirTask struct and fetch inherited data from parent task.
func NewDeleteDir(task navvy.Task) *DeleteDirTask {
	t := &DeleteDirTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteDirTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task DeleteDir value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task DeleteDir value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteDirTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *DeleteDirTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *DeleteDirTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteDirTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeleteDirTask) String() string {
	s := make([]string, 0, 2)
	if t.ValidatePath() {
		s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	}
	if t.ValidateStorage() {
		s = append(s, fmt.Sprintf("Storage: %s", t.Storage.String()))
	}
	return fmt.Sprintf("DeleteDirTask {%s}", strings.Join(s, ", "))
}

// NewDeleteDirTask will create a DeleteDirTask which meets navvy.Task.
func NewDeleteDirTask(task navvy.Task) navvy.Task {
	return NewDeleteDir(task)
}

// DeleteFileTask will will delete a file from storage.
type DeleteFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Path
	types.Storage

	// Output value
	types.HandleObjCallback
}

// NewDeleteFile will create a DeleteFileTask struct and fetch inherited data from parent task.
func NewDeleteFile(task navvy.Task) *DeleteFileTask {
	t := &DeleteFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteFileTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task DeleteFile value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task DeleteFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *DeleteFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *DeleteFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeleteFileTask) String() string {
	s := make([]string, 0, 2)
	if t.ValidatePath() {
		s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	}
	if t.ValidateStorage() {
		s = append(s, fmt.Sprintf("Storage: %s", t.Storage.String()))
	}
	return fmt.Sprintf("DeleteFileTask {%s}", strings.Join(s, ", "))
}

// NewDeleteFileTask will create a DeleteFileTask which meets navvy.Task.
func NewDeleteFileTask(task navvy.Task) navvy.Task {
	return NewDeleteFile(task)
}

// DeletePrefixTask will will delete objects with given prefix from storage.
type DeletePrefixTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Path
	types.Storage

	// Output value
	types.HandleObjCallback
}

// NewDeletePrefix will create a DeletePrefixTask struct and fetch inherited data from parent task.
func NewDeletePrefix(task navvy.Task) *DeletePrefixTask {
	t := &DeletePrefixTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeletePrefixTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task DeletePrefix value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task DeletePrefix value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeletePrefixTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *DeletePrefixTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *DeletePrefixTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeletePrefixTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeletePrefixTask) String() string {
	s := make([]string, 0, 2)
	if t.ValidatePath() {
		s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	}
	if t.ValidateStorage() {
		s = append(s, fmt.Sprintf("Storage: %s", t.Storage.String()))
	}
	return fmt.Sprintf("DeletePrefixTask {%s}", strings.Join(s, ", "))
}

// NewDeletePrefixTask will create a DeletePrefixTask which meets navvy.Task.
func NewDeletePrefixTask(task navvy.Task) navvy.Task {
	return NewDeletePrefix(task)
}

// DeleteSegmentTask will delete all segments with a given path.
type DeleteSegmentTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.PrefixSegmentsLister
	types.Segment

	// Output value
	types.HandleSegmentCallback
}

// NewDeleteSegment will create a DeleteSegmentTask struct and fetch inherited data from parent task.
func NewDeleteSegment(task navvy.Task) *DeleteSegmentTask {
	t := &DeleteSegmentTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteSegmentTask) validateInput() {
	if !t.ValidatePrefixSegmentsLister() {
		panic(fmt.Errorf("Task DeleteSegment value PrefixSegmentsLister is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task DeleteSegment value Segment is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteSegmentTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPrefixSegmentsLister(task, t)
	types.LoadSegment(task, t)
}

// Run implement navvy.Task
func (t *DeleteSegmentTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *DeleteSegmentTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteSegmentTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeleteSegmentTask) String() string {
	s := make([]string, 0, 2)
	if t.ValidatePrefixSegmentsLister() {
		s = append(s, fmt.Sprintf("PrefixSegmentsLister: %s", t.PrefixSegmentsLister.String()))
	}
	if t.ValidateSegment() {
		s = append(s, fmt.Sprintf("Segment: %s", t.Segment.String()))
	}
	return fmt.Sprintf("DeleteSegmentTask {%s}", strings.Join(s, ", "))
}

// NewDeleteSegmentTask will create a DeleteSegmentTask which meets navvy.Task.
func NewDeleteSegmentTask(task navvy.Task) navvy.Task {
	return NewDeleteSegment(task)
}

// DeleteStorageTask will delete a storage.
type DeleteStorageTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Force
	types.Service
	types.StorageName
	types.Zone

	// Output value
	types.HandleObjCallback
	types.HandleSegmentCallback
}

// NewDeleteStorage will create a DeleteStorageTask struct and fetch inherited data from parent task.
func NewDeleteStorage(task navvy.Task) *DeleteStorageTask {
	t := &DeleteStorageTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteStorageTask) validateInput() {
	if !t.ValidateForce() {
		panic(fmt.Errorf("Task DeleteStorage value Force is invalid"))
	}
	if !t.ValidateService() {
		panic(fmt.Errorf("Task DeleteStorage value Service is invalid"))
	}
	if !t.ValidateStorageName() {
		panic(fmt.Errorf("Task DeleteStorage value StorageName is invalid"))
	}
	if !t.ValidateZone() {
		panic(fmt.Errorf("Task DeleteStorage value Zone is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteStorageTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadForce(task, t)
	types.LoadService(task, t)
	types.LoadStorageName(task, t)
	types.LoadZone(task, t)
}

// Run implement navvy.Task
func (t *DeleteStorageTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *DeleteStorageTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteStorageTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeleteStorageTask) String() string {
	s := make([]string, 0, 4)
	if t.ValidateForce() {
		s = append(s, fmt.Sprintf("Force: %s", t.Force.String()))
	}
	if t.ValidateService() {
		s = append(s, fmt.Sprintf("Service: %s", t.Service.String()))
	}
	if t.ValidateStorageName() {
		s = append(s, fmt.Sprintf("StorageName: %s", t.StorageName.String()))
	}
	if t.ValidateZone() {
		s = append(s, fmt.Sprintf("Zone: %s", t.Zone.String()))
	}
	return fmt.Sprintf("DeleteStorageTask {%s}", strings.Join(s, ", "))
}

// NewDeleteStorageTask will create a DeleteStorageTask which meets navvy.Task.
func NewDeleteStorageTask(task navvy.Task) navvy.Task {
	return NewDeleteStorage(task)
}

// InitSegmentStreamTask will init a partial stream between two storager.
type InitSegmentStreamTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.BytesPool
	types.PartSize
	types.SourcePath
	types.SourceStorage

	// Output value
	types.Content
	types.Done
	types.Size
}

// NewInitSegmentStream will create a InitSegmentStreamTask struct and fetch inherited data from parent task.
func NewInitSegmentStream(task navvy.Task) *InitSegmentStreamTask {
	t := &InitSegmentStreamTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *InitSegmentStreamTask) validateInput() {
	if !t.ValidateBytesPool() {
		panic(fmt.Errorf("Task InitSegmentStream value BytesPool is invalid"))
	}
	if !t.ValidatePartSize() {
		panic(fmt.Errorf("Task InitSegmentStream value PartSize is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task InitSegmentStream value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task InitSegmentStream value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *InitSegmentStreamTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadBytesPool(task, t)
	types.LoadPartSize(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *InitSegmentStreamTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *InitSegmentStreamTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *InitSegmentStreamTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *InitSegmentStreamTask) String() string {
	s := make([]string, 0, 4)
	if t.ValidateBytesPool() {
		s = append(s, fmt.Sprintf("BytesPool: %s", t.BytesPool.String()))
	}
	if t.ValidatePartSize() {
		s = append(s, fmt.Sprintf("PartSize: %s", t.PartSize.String()))
	}
	if t.ValidateSourcePath() {
		s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	}
	if t.ValidateSourceStorage() {
		s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	}
	return fmt.Sprintf("InitSegmentStreamTask {%s}", strings.Join(s, ", "))
}

// NewInitSegmentStreamTask will create a InitSegmentStreamTask which meets navvy.Task.
func NewInitSegmentStreamTask(task navvy.Task) navvy.Task {
	return NewInitSegmentStream(task)
}

// IsDestinationObjectExistTask will .
type IsDestinationObjectExistTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.DestinationObject

	// Output value
	types.Result
}

// NewIsDestinationObjectExist will create a IsDestinationObjectExistTask struct and fetch inherited data from parent task.
func NewIsDestinationObjectExist(task navvy.Task) *IsDestinationObjectExistTask {
	t := &IsDestinationObjectExistTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IsDestinationObjectExistTask) validateInput() {
	if !t.ValidateDestinationObject() {
		panic(fmt.Errorf("Task IsDestinationObjectExist value DestinationObject is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IsDestinationObjectExistTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationObject(task, t)
}

// Run implement navvy.Task
func (t *IsDestinationObjectExistTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *IsDestinationObjectExistTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *IsDestinationObjectExistTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *IsDestinationObjectExistTask) String() string {
	s := make([]string, 0, 1)
	if t.ValidateDestinationObject() {
		s = append(s, fmt.Sprintf("DestinationObject: %s", t.DestinationObject.String()))
	}
	return fmt.Sprintf("IsDestinationObjectExistTask {%s}", strings.Join(s, ", "))
}

// NewIsDestinationObjectExistTask will create a IsDestinationObjectExistTask which meets navvy.Task.
func NewIsDestinationObjectExistTask(task navvy.Task) navvy.Task {
	return NewIsDestinationObjectExist(task)
}

// IsDestinationObjectNotExistTask will .
type IsDestinationObjectNotExistTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.DestinationObject

	// Output value
	types.Result
}

// NewIsDestinationObjectNotExist will create a IsDestinationObjectNotExistTask struct and fetch inherited data from parent task.
func NewIsDestinationObjectNotExist(task navvy.Task) *IsDestinationObjectNotExistTask {
	t := &IsDestinationObjectNotExistTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IsDestinationObjectNotExistTask) validateInput() {
	if !t.ValidateDestinationObject() {
		panic(fmt.Errorf("Task IsDestinationObjectNotExist value DestinationObject is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IsDestinationObjectNotExistTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationObject(task, t)
}

// Run implement navvy.Task
func (t *IsDestinationObjectNotExistTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *IsDestinationObjectNotExistTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *IsDestinationObjectNotExistTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *IsDestinationObjectNotExistTask) String() string {
	s := make([]string, 0, 1)
	if t.ValidateDestinationObject() {
		s = append(s, fmt.Sprintf("DestinationObject: %s", t.DestinationObject.String()))
	}
	return fmt.Sprintf("IsDestinationObjectNotExistTask {%s}", strings.Join(s, ", "))
}

// NewIsDestinationObjectNotExistTask will create a IsDestinationObjectNotExistTask which meets navvy.Task.
func NewIsDestinationObjectNotExistTask(task navvy.Task) navvy.Task {
	return NewIsDestinationObjectNotExist(task)
}

// IsSizeEqualTask will .
type IsSizeEqualTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.DestinationObject
	types.SourceObject

	// Output value
	types.Result
}

// NewIsSizeEqual will create a IsSizeEqualTask struct and fetch inherited data from parent task.
func NewIsSizeEqual(task navvy.Task) *IsSizeEqualTask {
	t := &IsSizeEqualTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IsSizeEqualTask) validateInput() {
	if !t.ValidateDestinationObject() {
		panic(fmt.Errorf("Task IsSizeEqual value DestinationObject is invalid"))
	}
	if !t.ValidateSourceObject() {
		panic(fmt.Errorf("Task IsSizeEqual value SourceObject is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IsSizeEqualTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationObject(task, t)
	types.LoadSourceObject(task, t)
}

// Run implement navvy.Task
func (t *IsSizeEqualTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *IsSizeEqualTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *IsSizeEqualTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *IsSizeEqualTask) String() string {
	s := make([]string, 0, 2)
	if t.ValidateDestinationObject() {
		s = append(s, fmt.Sprintf("DestinationObject: %s", t.DestinationObject.String()))
	}
	if t.ValidateSourceObject() {
		s = append(s, fmt.Sprintf("SourceObject: %s", t.SourceObject.String()))
	}
	return fmt.Sprintf("IsSizeEqualTask {%s}", strings.Join(s, ", "))
}

// NewIsSizeEqualTask will create a IsSizeEqualTask which meets navvy.Task.
func NewIsSizeEqualTask(task navvy.Task) navvy.Task {
	return NewIsSizeEqual(task)
}

// IsSourcePathExcludeIncludeTask will check whether source path is excluded or included.
type IsSourcePathExcludeIncludeTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.ExcludeRegexp
	types.IncludeRegexp
	types.SourcePath

	// Output value
	types.Result
}

// NewIsSourcePathExcludeInclude will create a IsSourcePathExcludeIncludeTask struct and fetch inherited data from parent task.
func NewIsSourcePathExcludeInclude(task navvy.Task) *IsSourcePathExcludeIncludeTask {
	t := &IsSourcePathExcludeIncludeTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IsSourcePathExcludeIncludeTask) validateInput() {
	if !t.ValidateExcludeRegexp() {
		panic(fmt.Errorf("Task IsSourcePathExcludeInclude value ExcludeRegexp is invalid"))
	}
	if !t.ValidateIncludeRegexp() {
		panic(fmt.Errorf("Task IsSourcePathExcludeInclude value IncludeRegexp is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task IsSourcePathExcludeInclude value SourcePath is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IsSourcePathExcludeIncludeTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadExcludeRegexp(task, t)
	types.LoadIncludeRegexp(task, t)
	types.LoadSourcePath(task, t)
}

// Run implement navvy.Task
func (t *IsSourcePathExcludeIncludeTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *IsSourcePathExcludeIncludeTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *IsSourcePathExcludeIncludeTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *IsSourcePathExcludeIncludeTask) String() string {
	s := make([]string, 0, 3)
	if t.ValidateExcludeRegexp() {
		s = append(s, fmt.Sprintf("ExcludeRegexp: %s", t.ExcludeRegexp.String()))
	}
	if t.ValidateIncludeRegexp() {
		s = append(s, fmt.Sprintf("IncludeRegexp: %s", t.IncludeRegexp.String()))
	}
	if t.ValidateSourcePath() {
		s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	}
	return fmt.Sprintf("IsSourcePathExcludeIncludeTask {%s}", strings.Join(s, ", "))
}

// NewIsSourcePathExcludeIncludeTask will create a IsSourcePathExcludeIncludeTask which meets navvy.Task.
func NewIsSourcePathExcludeIncludeTask(task navvy.Task) navvy.Task {
	return NewIsSourcePathExcludeInclude(task)
}

// IsUpdateAtGreaterTask will .
type IsUpdateAtGreaterTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.DestinationObject
	types.SourceObject

	// Output value
	types.Result
}

// NewIsUpdateAtGreater will create a IsUpdateAtGreaterTask struct and fetch inherited data from parent task.
func NewIsUpdateAtGreater(task navvy.Task) *IsUpdateAtGreaterTask {
	t := &IsUpdateAtGreaterTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IsUpdateAtGreaterTask) validateInput() {
	if !t.ValidateDestinationObject() {
		panic(fmt.Errorf("Task IsUpdateAtGreater value DestinationObject is invalid"))
	}
	if !t.ValidateSourceObject() {
		panic(fmt.Errorf("Task IsUpdateAtGreater value SourceObject is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IsUpdateAtGreaterTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationObject(task, t)
	types.LoadSourceObject(task, t)
}

// Run implement navvy.Task
func (t *IsUpdateAtGreaterTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *IsUpdateAtGreaterTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *IsUpdateAtGreaterTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *IsUpdateAtGreaterTask) String() string {
	s := make([]string, 0, 2)
	if t.ValidateDestinationObject() {
		s = append(s, fmt.Sprintf("DestinationObject: %s", t.DestinationObject.String()))
	}
	if t.ValidateSourceObject() {
		s = append(s, fmt.Sprintf("SourceObject: %s", t.SourceObject.String()))
	}
	return fmt.Sprintf("IsUpdateAtGreaterTask {%s}", strings.Join(s, ", "))
}

// NewIsUpdateAtGreaterTask will create a IsUpdateAtGreaterTask which meets navvy.Task.
func NewIsUpdateAtGreaterTask(task navvy.Task) navvy.Task {
	return NewIsUpdateAtGreater(task)
}

// ListDirTask will list dirs.
type ListDirTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.DirFunc
	types.DirLister
	types.FileFunc
	types.Path

	// Output value
}

// NewListDir will create a ListDirTask struct and fetch inherited data from parent task.
func NewListDir(task navvy.Task) *ListDirTask {
	t := &ListDirTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ListDirTask) validateInput() {
	if !t.ValidateDirFunc() {
		panic(fmt.Errorf("Task ListDir value DirFunc is invalid"))
	}
	if !t.ValidateDirLister() {
		panic(fmt.Errorf("Task ListDir value DirLister is invalid"))
	}
	if !t.ValidateFileFunc() {
		panic(fmt.Errorf("Task ListDir value FileFunc is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ListDir value Path is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ListDirTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDirFunc(task, t)
	types.LoadDirLister(task, t)
	types.LoadFileFunc(task, t)
	types.LoadPath(task, t)
}

// Run implement navvy.Task
func (t *ListDirTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *ListDirTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *ListDirTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ListDirTask) String() string {
	s := make([]string, 0, 4)
	if t.ValidateDirLister() {
		s = append(s, fmt.Sprintf("DirLister: %s", t.DirLister.String()))
	}
	if t.ValidatePath() {
		s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	}
	return fmt.Sprintf("ListDirTask {%s}", strings.Join(s, ", "))
}

// NewListDirTask will create a ListDirTask which meets navvy.Task.
func NewListDirTask(task navvy.Task) navvy.Task {
	return NewListDir(task)
}

// ListPrefixTask will list prefix.
type ListPrefixTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.ObjectFunc
	types.Path
	types.PrefixLister

	// Output value
}

// NewListPrefix will create a ListPrefixTask struct and fetch inherited data from parent task.
func NewListPrefix(task navvy.Task) *ListPrefixTask {
	t := &ListPrefixTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ListPrefixTask) validateInput() {
	if !t.ValidateObjectFunc() {
		panic(fmt.Errorf("Task ListPrefix value ObjectFunc is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ListPrefix value Path is invalid"))
	}
	if !t.ValidatePrefixLister() {
		panic(fmt.Errorf("Task ListPrefix value PrefixLister is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ListPrefixTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadObjectFunc(task, t)
	types.LoadPath(task, t)
	types.LoadPrefixLister(task, t)
}

// Run implement navvy.Task
func (t *ListPrefixTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *ListPrefixTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *ListPrefixTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ListPrefixTask) String() string {
	s := make([]string, 0, 3)
	if t.ValidatePath() {
		s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	}
	if t.ValidatePrefixLister() {
		s = append(s, fmt.Sprintf("PrefixLister: %s", t.PrefixLister.String()))
	}
	return fmt.Sprintf("ListPrefixTask {%s}", strings.Join(s, ", "))
}

// NewListPrefixTask will create a ListPrefixTask which meets navvy.Task.
func NewListPrefixTask(task navvy.Task) navvy.Task {
	return NewListPrefix(task)
}

// ListSegmentTask will list segments.
type ListSegmentTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Path
	types.PrefixSegmentsLister
	types.SegmentFunc

	// Output value
}

// NewListSegment will create a ListSegmentTask struct and fetch inherited data from parent task.
func NewListSegment(task navvy.Task) *ListSegmentTask {
	t := &ListSegmentTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ListSegmentTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ListSegment value Path is invalid"))
	}
	if !t.ValidatePrefixSegmentsLister() {
		panic(fmt.Errorf("Task ListSegment value PrefixSegmentsLister is invalid"))
	}
	if !t.ValidateSegmentFunc() {
		panic(fmt.Errorf("Task ListSegment value SegmentFunc is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ListSegmentTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadPrefixSegmentsLister(task, t)
	types.LoadSegmentFunc(task, t)
}

// Run implement navvy.Task
func (t *ListSegmentTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *ListSegmentTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *ListSegmentTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ListSegmentTask) String() string {
	s := make([]string, 0, 3)
	if t.ValidatePath() {
		s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	}
	if t.ValidatePrefixSegmentsLister() {
		s = append(s, fmt.Sprintf("PrefixSegmentsLister: %s", t.PrefixSegmentsLister.String()))
	}
	return fmt.Sprintf("ListSegmentTask {%s}", strings.Join(s, ", "))
}

// NewListSegmentTask will create a ListSegmentTask which meets navvy.Task.
func NewListSegmentTask(task navvy.Task) navvy.Task {
	return NewListSegment(task)
}

// ListStorageTask will send get request to get bucket list.
type ListStorageTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Service
	types.StoragerFunc
	types.Zone

	// Output value
}

// NewListStorage will create a ListStorageTask struct and fetch inherited data from parent task.
func NewListStorage(task navvy.Task) *ListStorageTask {
	t := &ListStorageTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ListStorageTask) validateInput() {
	if !t.ValidateService() {
		panic(fmt.Errorf("Task ListStorage value Service is invalid"))
	}
	if !t.ValidateStoragerFunc() {
		panic(fmt.Errorf("Task ListStorage value StoragerFunc is invalid"))
	}
	if !t.ValidateZone() {
		panic(fmt.Errorf("Task ListStorage value Zone is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ListStorageTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadService(task, t)
	types.LoadStoragerFunc(task, t)
	types.LoadZone(task, t)
}

// Run implement navvy.Task
func (t *ListStorageTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *ListStorageTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *ListStorageTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ListStorageTask) String() string {
	s := make([]string, 0, 3)
	if t.ValidateService() {
		s = append(s, fmt.Sprintf("Service: %s", t.Service.String()))
	}
	if t.ValidateZone() {
		s = append(s, fmt.Sprintf("Zone: %s", t.Zone.String()))
	}
	return fmt.Sprintf("ListStorageTask {%s}", strings.Join(s, ", "))
}

// NewListStorageTask will create a ListStorageTask which meets navvy.Task.
func NewListStorageTask(task navvy.Task) navvy.Task {
	return NewListStorage(task)
}

// MD5SumFileTask will get file's md5 sum.
type MD5SumFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Offset
	types.Path
	types.Size
	types.Storage

	// Output value
	types.MD5Sum
}

// NewMD5SumFile will create a MD5SumFileTask struct and fetch inherited data from parent task.
func NewMD5SumFile(task navvy.Task) *MD5SumFileTask {
	t := &MD5SumFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MD5SumFileTask) validateInput() {
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task MD5SumFile value Offset is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task MD5SumFile value Path is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task MD5SumFile value Size is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task MD5SumFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MD5SumFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadOffset(task, t)
	types.LoadPath(task, t)
	types.LoadSize(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *MD5SumFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *MD5SumFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *MD5SumFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *MD5SumFileTask) String() string {
	s := make([]string, 0, 4)
	if t.ValidateOffset() {
		s = append(s, fmt.Sprintf("Offset: %s", t.Offset.String()))
	}
	if t.ValidatePath() {
		s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	}
	if t.ValidateSize() {
		s = append(s, fmt.Sprintf("Size: %s", t.Size.String()))
	}
	if t.ValidateStorage() {
		s = append(s, fmt.Sprintf("Storage: %s", t.Storage.String()))
	}
	return fmt.Sprintf("MD5SumFileTask {%s}", strings.Join(s, ", "))
}

// NewMD5SumFileTask will create a MD5SumFileTask which meets navvy.Task.
func NewMD5SumFileTask(task navvy.Task) navvy.Task {
	return NewMD5SumFile(task)
}

// MD5SumStreamTask will get stream's md5 sum.
type MD5SumStreamTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Content

	// Output value
	types.MD5Sum
}

// NewMD5SumStream will create a MD5SumStreamTask struct and fetch inherited data from parent task.
func NewMD5SumStream(task navvy.Task) *MD5SumStreamTask {
	t := &MD5SumStreamTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MD5SumStreamTask) validateInput() {
	if !t.ValidateContent() {
		panic(fmt.Errorf("Task MD5SumStream value Content is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MD5SumStreamTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadContent(task, t)
}

// Run implement navvy.Task
func (t *MD5SumStreamTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *MD5SumStreamTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *MD5SumStreamTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *MD5SumStreamTask) String() string {
	s := make([]string, 0, 1)
	if t.ValidateContent() {
		s = append(s, fmt.Sprintf("Content: %s", t.Content.String()))
	}
	return fmt.Sprintf("MD5SumStreamTask {%s}", strings.Join(s, ", "))
}

// NewMD5SumStreamTask will create a MD5SumStreamTask which meets navvy.Task.
func NewMD5SumStreamTask(task navvy.Task) navvy.Task {
	return NewMD5SumStream(task)
}

// MoveDirTask will move a directory recursively between two storager.
type MoveDirTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.CheckTasks
	types.DestinationPath
	types.DestinationStorage
	types.PartThreshold
	types.SourcePath
	types.SourceStorage

	// Output value
	types.HandleObjCallback
	types.PartSize
}

// NewMoveDir will create a MoveDirTask struct and fetch inherited data from parent task.
func NewMoveDir(task navvy.Task) *MoveDirTask {
	t := &MoveDirTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MoveDirTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task MoveDir value CheckMD5 is invalid"))
	}
	if !t.ValidateCheckTasks() {
		panic(fmt.Errorf("Task MoveDir value CheckTasks is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task MoveDir value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task MoveDir value DestinationStorage is invalid"))
	}
	if !t.ValidatePartThreshold() {
		panic(fmt.Errorf("Task MoveDir value PartThreshold is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task MoveDir value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task MoveDir value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MoveDirTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadCheckTasks(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadPartThreshold(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *MoveDirTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *MoveDirTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *MoveDirTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *MoveDirTask) String() string {
	s := make([]string, 0, 7)
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidateCheckTasks() {
		s = append(s, fmt.Sprintf("CheckTasks: %s", t.CheckTasks.String()))
	}
	if t.ValidateDestinationPath() {
		s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	}
	if t.ValidateDestinationStorage() {
		s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	}
	if t.ValidatePartThreshold() {
		s = append(s, fmt.Sprintf("PartThreshold: %s", t.PartThreshold.String()))
	}
	if t.ValidateSourcePath() {
		s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	}
	if t.ValidateSourceStorage() {
		s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	}
	return fmt.Sprintf("MoveDirTask {%s}", strings.Join(s, ", "))
}

// NewMoveDirTask will create a MoveDirTask which meets navvy.Task.
func NewMoveDirTask(task navvy.Task) navvy.Task {
	return NewMoveDir(task)
}

// MoveFileTask will move a file between two storager.
type MoveFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.CheckTasks
	types.DestinationPath
	types.DestinationStorage
	types.PartThreshold
	types.SourcePath
	types.SourceStorage

	// Output value
	types.HandleObjCallback
	types.PartSize
}

// NewMoveFile will create a MoveFileTask struct and fetch inherited data from parent task.
func NewMoveFile(task navvy.Task) *MoveFileTask {
	t := &MoveFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MoveFileTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task MoveFile value CheckMD5 is invalid"))
	}
	if !t.ValidateCheckTasks() {
		panic(fmt.Errorf("Task MoveFile value CheckTasks is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task MoveFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task MoveFile value DestinationStorage is invalid"))
	}
	if !t.ValidatePartThreshold() {
		panic(fmt.Errorf("Task MoveFile value PartThreshold is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task MoveFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task MoveFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MoveFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadCheckTasks(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadPartThreshold(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *MoveFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *MoveFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *MoveFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *MoveFileTask) String() string {
	s := make([]string, 0, 7)
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidateCheckTasks() {
		s = append(s, fmt.Sprintf("CheckTasks: %s", t.CheckTasks.String()))
	}
	if t.ValidateDestinationPath() {
		s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	}
	if t.ValidateDestinationStorage() {
		s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	}
	if t.ValidatePartThreshold() {
		s = append(s, fmt.Sprintf("PartThreshold: %s", t.PartThreshold.String()))
	}
	if t.ValidateSourcePath() {
		s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	}
	if t.ValidateSourceStorage() {
		s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	}
	return fmt.Sprintf("MoveFileTask {%s}", strings.Join(s, ", "))
}

// NewMoveFileTask will create a MoveFileTask which meets navvy.Task.
func NewMoveFileTask(task navvy.Task) navvy.Task {
	return NewMoveFile(task)
}

// ReachFileTask will will reach a remote object and return the signed url.
type ReachFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Expire
	types.Path
	types.Reacher

	// Output value
	types.URL
}

// NewReachFile will create a ReachFileTask struct and fetch inherited data from parent task.
func NewReachFile(task navvy.Task) *ReachFileTask {
	t := &ReachFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ReachFileTask) validateInput() {
	if !t.ValidateExpire() {
		panic(fmt.Errorf("Task ReachFile value Expire is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ReachFile value Path is invalid"))
	}
	if !t.ValidateReacher() {
		panic(fmt.Errorf("Task ReachFile value Reacher is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ReachFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadExpire(task, t)
	types.LoadPath(task, t)
	types.LoadReacher(task, t)
}

// Run implement navvy.Task
func (t *ReachFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *ReachFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *ReachFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ReachFileTask) String() string {
	s := make([]string, 0, 3)
	if t.ValidateExpire() {
		s = append(s, fmt.Sprintf("Expire: %s", t.Expire.String()))
	}
	if t.ValidatePath() {
		s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	}
	if t.ValidateReacher() {
		s = append(s, fmt.Sprintf("Reacher: %s", t.Reacher.String()))
	}
	return fmt.Sprintf("ReachFileTask {%s}", strings.Join(s, ", "))
}

// NewReachFileTask will create a ReachFileTask which meets navvy.Task.
func NewReachFileTask(task navvy.Task) navvy.Task {
	return NewReachFile(task)
}

// SegmentCompleteTask will complete a segment.
type SegmentCompleteTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.IndexSegmenter
	types.Path
	types.Segment

	// Output value
}

// NewSegmentComplete will create a SegmentCompleteTask struct and fetch inherited data from parent task.
func NewSegmentComplete(task navvy.Task) *SegmentCompleteTask {
	t := &SegmentCompleteTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentCompleteTask) validateInput() {
	if !t.ValidateIndexSegmenter() {
		panic(fmt.Errorf("Task SegmentComplete value IndexSegmenter is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task SegmentComplete value Path is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task SegmentComplete value Segment is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentCompleteTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadIndexSegmenter(task, t)
	types.LoadPath(task, t)
	types.LoadSegment(task, t)
}

// Run implement navvy.Task
func (t *SegmentCompleteTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *SegmentCompleteTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentCompleteTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SegmentCompleteTask) String() string {
	s := make([]string, 0, 3)
	if t.ValidateIndexSegmenter() {
		s = append(s, fmt.Sprintf("IndexSegmenter: %s", t.IndexSegmenter.String()))
	}
	if t.ValidatePath() {
		s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	}
	if t.ValidateSegment() {
		s = append(s, fmt.Sprintf("Segment: %s", t.Segment.String()))
	}
	return fmt.Sprintf("SegmentCompleteTask {%s}", strings.Join(s, ", "))
}

// NewSegmentCompleteTask will create a SegmentCompleteTask which meets navvy.Task.
func NewSegmentCompleteTask(task navvy.Task) navvy.Task {
	return NewSegmentComplete(task)
}

// SegmentFileCopyTask will copy a segment file.
type SegmentFileCopyTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.DestinationIndexSegmenter
	types.DestinationPath
	types.Index
	types.MD5Sum
	types.Offset
	types.Segment
	types.Size
	types.SourcePath
	types.SourceStorage

	// Output value
}

// NewSegmentFileCopy will create a SegmentFileCopyTask struct and fetch inherited data from parent task.
func NewSegmentFileCopy(task navvy.Task) *SegmentFileCopyTask {
	t := &SegmentFileCopyTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentFileCopyTask) validateInput() {
	if !t.ValidateDestinationIndexSegmenter() {
		panic(fmt.Errorf("Task SegmentFileCopy value DestinationIndexSegmenter is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task SegmentFileCopy value DestinationPath is invalid"))
	}
	if !t.ValidateIndex() {
		panic(fmt.Errorf("Task SegmentFileCopy value Index is invalid"))
	}
	if !t.ValidateMD5Sum() {
		panic(fmt.Errorf("Task SegmentFileCopy value MD5Sum is invalid"))
	}
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task SegmentFileCopy value Offset is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task SegmentFileCopy value Segment is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task SegmentFileCopy value Size is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task SegmentFileCopy value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task SegmentFileCopy value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentFileCopyTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationIndexSegmenter(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadIndex(task, t)
	types.LoadMD5Sum(task, t)
	types.LoadOffset(task, t)
	types.LoadSegment(task, t)
	types.LoadSize(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *SegmentFileCopyTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *SegmentFileCopyTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentFileCopyTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SegmentFileCopyTask) String() string {
	s := make([]string, 0, 9)
	if t.ValidateDestinationIndexSegmenter() {
		s = append(s, fmt.Sprintf("DestinationIndexSegmenter: %s", t.DestinationIndexSegmenter.String()))
	}
	if t.ValidateDestinationPath() {
		s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	}
	if t.ValidateIndex() {
		s = append(s, fmt.Sprintf("Index: %s", t.Index.String()))
	}
	if t.ValidateMD5Sum() {
		s = append(s, fmt.Sprintf("MD5Sum: %s", t.MD5Sum.String()))
	}
	if t.ValidateOffset() {
		s = append(s, fmt.Sprintf("Offset: %s", t.Offset.String()))
	}
	if t.ValidateSegment() {
		s = append(s, fmt.Sprintf("Segment: %s", t.Segment.String()))
	}
	if t.ValidateSize() {
		s = append(s, fmt.Sprintf("Size: %s", t.Size.String()))
	}
	if t.ValidateSourcePath() {
		s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	}
	if t.ValidateSourceStorage() {
		s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	}
	return fmt.Sprintf("SegmentFileCopyTask {%s}", strings.Join(s, ", "))
}

// NewSegmentFileCopyTask will create a SegmentFileCopyTask which meets navvy.Task.
func NewSegmentFileCopyTask(task navvy.Task) navvy.Task {
	return NewSegmentFileCopy(task)
}

// SegmentInitTask will init a segment upload.
type SegmentInitTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.IndexSegmenter
	types.PartSize
	types.Path

	// Output value
	types.Segment
}

// NewSegmentInit will create a SegmentInitTask struct and fetch inherited data from parent task.
func NewSegmentInit(task navvy.Task) *SegmentInitTask {
	t := &SegmentInitTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentInitTask) validateInput() {
	if !t.ValidateIndexSegmenter() {
		panic(fmt.Errorf("Task SegmentInit value IndexSegmenter is invalid"))
	}
	if !t.ValidatePartSize() {
		panic(fmt.Errorf("Task SegmentInit value PartSize is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task SegmentInit value Path is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentInitTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadIndexSegmenter(task, t)
	types.LoadPartSize(task, t)
	types.LoadPath(task, t)
}

// Run implement navvy.Task
func (t *SegmentInitTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *SegmentInitTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentInitTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SegmentInitTask) String() string {
	s := make([]string, 0, 3)
	if t.ValidateIndexSegmenter() {
		s = append(s, fmt.Sprintf("IndexSegmenter: %s", t.IndexSegmenter.String()))
	}
	if t.ValidatePartSize() {
		s = append(s, fmt.Sprintf("PartSize: %s", t.PartSize.String()))
	}
	if t.ValidatePath() {
		s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	}
	return fmt.Sprintf("SegmentInitTask {%s}", strings.Join(s, ", "))
}

// NewSegmentInitTask will create a SegmentInitTask which meets navvy.Task.
func NewSegmentInitTask(task navvy.Task) navvy.Task {
	return NewSegmentInit(task)
}

// SegmentStreamCopyTask will copy a segment stream.
type SegmentStreamCopyTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Content
	types.DestinationIndexSegmenter
	types.DestinationPath
	types.Index
	types.MD5Sum
	types.Offset
	types.Segment
	types.Size

	// Output value
}

// NewSegmentStreamCopy will create a SegmentStreamCopyTask struct and fetch inherited data from parent task.
func NewSegmentStreamCopy(task navvy.Task) *SegmentStreamCopyTask {
	t := &SegmentStreamCopyTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentStreamCopyTask) validateInput() {
	if !t.ValidateContent() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Content is invalid"))
	}
	if !t.ValidateDestinationIndexSegmenter() {
		panic(fmt.Errorf("Task SegmentStreamCopy value DestinationIndexSegmenter is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task SegmentStreamCopy value DestinationPath is invalid"))
	}
	if !t.ValidateIndex() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Index is invalid"))
	}
	if !t.ValidateMD5Sum() {
		panic(fmt.Errorf("Task SegmentStreamCopy value MD5Sum is invalid"))
	}
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Offset is invalid"))
	}
	if !t.ValidateSegment() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Segment is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Size is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentStreamCopyTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadContent(task, t)
	types.LoadDestinationIndexSegmenter(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadIndex(task, t)
	types.LoadMD5Sum(task, t)
	types.LoadOffset(task, t)
	types.LoadSegment(task, t)
	types.LoadSize(task, t)
}

// Run implement navvy.Task
func (t *SegmentStreamCopyTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *SegmentStreamCopyTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentStreamCopyTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SegmentStreamCopyTask) String() string {
	s := make([]string, 0, 8)
	if t.ValidateContent() {
		s = append(s, fmt.Sprintf("Content: %s", t.Content.String()))
	}
	if t.ValidateDestinationIndexSegmenter() {
		s = append(s, fmt.Sprintf("DestinationIndexSegmenter: %s", t.DestinationIndexSegmenter.String()))
	}
	if t.ValidateDestinationPath() {
		s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	}
	if t.ValidateIndex() {
		s = append(s, fmt.Sprintf("Index: %s", t.Index.String()))
	}
	if t.ValidateMD5Sum() {
		s = append(s, fmt.Sprintf("MD5Sum: %s", t.MD5Sum.String()))
	}
	if t.ValidateOffset() {
		s = append(s, fmt.Sprintf("Offset: %s", t.Offset.String()))
	}
	if t.ValidateSegment() {
		s = append(s, fmt.Sprintf("Segment: %s", t.Segment.String()))
	}
	if t.ValidateSize() {
		s = append(s, fmt.Sprintf("Size: %s", t.Size.String()))
	}
	return fmt.Sprintf("SegmentStreamCopyTask {%s}", strings.Join(s, ", "))
}

// NewSegmentStreamCopyTask will create a SegmentStreamCopyTask which meets navvy.Task.
func NewSegmentStreamCopyTask(task navvy.Task) navvy.Task {
	return NewSegmentStreamCopy(task)
}

// StatFileTask will stat a remote object by request headObject.
type StatFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Path
	types.Storage

	// Output value
	types.Object
}

// NewStatFile will create a StatFileTask struct and fetch inherited data from parent task.
func NewStatFile(task navvy.Task) *StatFileTask {
	t := &StatFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *StatFileTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task StatFile value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task StatFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *StatFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *StatFileTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *StatFileTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *StatFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *StatFileTask) String() string {
	s := make([]string, 0, 2)
	if t.ValidatePath() {
		s = append(s, fmt.Sprintf("Path: %s", t.Path.String()))
	}
	if t.ValidateStorage() {
		s = append(s, fmt.Sprintf("Storage: %s", t.Storage.String()))
	}
	return fmt.Sprintf("StatFileTask {%s}", strings.Join(s, ", "))
}

// NewStatFileTask will create a StatFileTask which meets navvy.Task.
func NewStatFileTask(task navvy.Task) navvy.Task {
	return NewStatFile(task)
}

// StatStorageTask will stat a remote storage by Statistical.
type StatStorageTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.Storage

	// Output value
	types.StorageInfo
}

// NewStatStorage will create a StatStorageTask struct and fetch inherited data from parent task.
func NewStatStorage(task navvy.Task) *StatStorageTask {
	t := &StatStorageTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *StatStorageTask) validateInput() {
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task StatStorage value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *StatStorageTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *StatStorageTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *StatStorageTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *StatStorageTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *StatStorageTask) String() string {
	s := make([]string, 0, 1)
	if t.ValidateStorage() {
		s = append(s, fmt.Sprintf("Storage: %s", t.Storage.String()))
	}
	return fmt.Sprintf("StatStorageTask {%s}", strings.Join(s, ", "))
}

// NewStatStorageTask will create a StatStorageTask which meets navvy.Task.
func NewStatStorageTask(task navvy.Task) navvy.Task {
	return NewStatStorage(task)
}

// SyncTask will sync directory between two storage.
type SyncTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler
	types.CallbackFunc

	// Input value
	types.CheckMD5
	types.CheckTasks
	types.DestinationPath
	types.DestinationStorage
	types.DryRunFunc
	types.PartThreshold
	types.Recursive
	types.SourcePath
	types.SourceStorage

	// Output value
	types.HandleObjCallback
	types.PartSize
}

// NewSync will create a SyncTask struct and fetch inherited data from parent task.
func NewSync(task navvy.Task) *SyncTask {
	t := &SyncTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SyncTask) validateInput() {
	if !t.ValidateCheckMD5() {
		panic(fmt.Errorf("Task Sync value CheckMD5 is invalid"))
	}
	if !t.ValidateCheckTasks() {
		panic(fmt.Errorf("Task Sync value CheckTasks is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task Sync value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task Sync value DestinationStorage is invalid"))
	}
	if !t.ValidateDryRunFunc() {
		panic(fmt.Errorf("Task Sync value DryRunFunc is invalid"))
	}
	if !t.ValidatePartThreshold() {
		panic(fmt.Errorf("Task Sync value PartThreshold is invalid"))
	}
	if !t.ValidateRecursive() {
		panic(fmt.Errorf("Task Sync value Recursive is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task Sync value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task Sync value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SyncTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckMD5(task, t)
	types.LoadCheckTasks(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadDryRunFunc(task, t)
	types.LoadPartThreshold(task, t)
	types.LoadRecursive(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *SyncTask) Run(ctx context.Context) {
	logger := log.FromContext(ctx)
	t.validateInput()

	logger.Debug(
		log.String("task_started", t.String()),
	)
	t.run(ctx)
	t.GetScheduler().Wait()
	if t.GetFault().HasError() {
		logger.Debug(
			log.String("task_failed", t.String()),
			log.String("err", t.GetFault().Error()),
		)
		return
	}
	if t.ValidateCallbackFunc() {
		t.GetCallbackFunc()()
	}
	logger.Debug(
		log.String("task_finished", t.String()),
	)
}

// Context implement navvy.Task
func (t *SyncTask) Context() context.Context {
	return context.TODO()
}

// TriggerFault will be used to trigger a task related fault.
func (t *SyncTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SyncTask) String() string {
	s := make([]string, 0, 9)
	if t.ValidateCheckMD5() {
		s = append(s, fmt.Sprintf("CheckMD5: %s", t.CheckMD5.String()))
	}
	if t.ValidateCheckTasks() {
		s = append(s, fmt.Sprintf("CheckTasks: %s", t.CheckTasks.String()))
	}
	if t.ValidateDestinationPath() {
		s = append(s, fmt.Sprintf("DestinationPath: %s", t.DestinationPath.String()))
	}
	if t.ValidateDestinationStorage() {
		s = append(s, fmt.Sprintf("DestinationStorage: %s", t.DestinationStorage.String()))
	}
	if t.ValidatePartThreshold() {
		s = append(s, fmt.Sprintf("PartThreshold: %s", t.PartThreshold.String()))
	}
	if t.ValidateRecursive() {
		s = append(s, fmt.Sprintf("Recursive: %s", t.Recursive.String()))
	}
	if t.ValidateSourcePath() {
		s = append(s, fmt.Sprintf("SourcePath: %s", t.SourcePath.String()))
	}
	if t.ValidateSourceStorage() {
		s = append(s, fmt.Sprintf("SourceStorage: %s", t.SourceStorage.String()))
	}
	return fmt.Sprintf("SyncTask {%s}", strings.Join(s, ", "))
}

// NewSyncTask will create a SyncTask which meets navvy.Task.
func NewSyncTask(task navvy.Task) navvy.Task {
	return NewSync(task)
}
