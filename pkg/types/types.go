// Code generated by go generate; DO NOT EDIT.
package types

import (
	"bytes"
	"fmt"
	"regexp"
	"strconv"
	"sync"

	"github.com/Xuanwo/navvy"
	"github.com/aos-dev/go-storage/v2"
	"github.com/aos-dev/go-storage/v2/pkg/segment"
	"github.com/aos-dev/go-storage/v2/types"
	"github.com/aos-dev/go-storage/v2/types/info"

	"github.com/qingstor/noah/pkg/fault"
	"github.com/qingstor/noah/pkg/schedule"
)

var _ fmt.Stringer

type ByteSize struct {
	valid bool
	v     string

	l sync.RWMutex
}

type ByteSizeGetter interface {
	GetByteSize() string
}

func (o *ByteSize) GetByteSize() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("ByteSize value is not valid")
	}
	return o.v
}

type ByteSizeSetter interface {
	SetByteSize(string)
}

func (o *ByteSize) SetByteSize(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ByteSizeValidator interface {
	ValidateByteSize() bool
}

func (o *ByteSize) ValidateByteSize() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadByteSize(t navvy.Task, v ByteSizeSetter) {
	x, ok := t.(interface {
		ByteSizeGetter
		ByteSizeValidator
	})
	if !ok {
		return
	}
	if !x.ValidateByteSize() {
		return
	}

	v.SetByteSize(x.GetByteSize())
}

func (o *ByteSize) String() string {
	if !o.valid {
		return ""
	}
	return o.v
}

type BytesPool struct {
	valid bool
	v     *sync.Pool

	l sync.RWMutex
}

type BytesPoolGetter interface {
	GetBytesPool() *sync.Pool
}

func (o *BytesPool) GetBytesPool() *sync.Pool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("BytesPool value is not valid")
	}
	return o.v
}

type BytesPoolSetter interface {
	SetBytesPool(*sync.Pool)
}

func (o *BytesPool) SetBytesPool(v *sync.Pool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type BytesPoolValidator interface {
	ValidateBytesPool() bool
}

func (o *BytesPool) ValidateBytesPool() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadBytesPool(t navvy.Task, v BytesPoolSetter) {
	x, ok := t.(interface {
		BytesPoolGetter
		BytesPoolValidator
	})
	if !ok {
		return
	}
	if !x.ValidateBytesPool() {
		return
	}

	v.SetBytesPool(x.GetBytesPool())
}

func (o *BytesPool) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type CallbackFunc struct {
	valid bool
	v     func()

	l sync.RWMutex
}

type CallbackFuncGetter interface {
	GetCallbackFunc() func()
}

func (o *CallbackFunc) GetCallbackFunc() func() {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("CallbackFunc value is not valid")
	}
	return o.v
}

type CallbackFuncSetter interface {
	SetCallbackFunc(func())
}

func (o *CallbackFunc) SetCallbackFunc(v func()) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type CallbackFuncValidator interface {
	ValidateCallbackFunc() bool
}

func (o *CallbackFunc) ValidateCallbackFunc() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadCallbackFunc(t navvy.Task, v CallbackFuncSetter) {
	x, ok := t.(interface {
		CallbackFuncGetter
		CallbackFuncValidator
	})
	if !ok {
		return
	}
	if !x.ValidateCallbackFunc() {
		return
	}

	v.SetCallbackFunc(x.GetCallbackFunc())
}

func (o *CallbackFunc) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type CheckMD5 struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type CheckMD5Getter interface {
	GetCheckMD5() bool
}

func (o *CheckMD5) GetCheckMD5() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("CheckMD5 value is not valid")
	}
	return o.v
}

type CheckMD5Setter interface {
	SetCheckMD5(bool)
}

func (o *CheckMD5) SetCheckMD5(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type CheckMD5Validator interface {
	ValidateCheckMD5() bool
}

func (o *CheckMD5) ValidateCheckMD5() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadCheckMD5(t navvy.Task, v CheckMD5Setter) {
	x, ok := t.(interface {
		CheckMD5Getter
		CheckMD5Validator
	})
	if !ok {
		return
	}
	if !x.ValidateCheckMD5() {
		return
	}

	v.SetCheckMD5(x.GetCheckMD5())
}

func (o *CheckMD5) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatBool(o.v)
}

type CheckTasks struct {
	valid bool
	v     []func(t navvy.Task) navvy.Task

	l sync.RWMutex
}

type CheckTasksGetter interface {
	GetCheckTasks() []func(t navvy.Task) navvy.Task
}

func (o *CheckTasks) GetCheckTasks() []func(t navvy.Task) navvy.Task {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("CheckTasks value is not valid")
	}
	return o.v
}

type CheckTasksSetter interface {
	SetCheckTasks([]func(t navvy.Task) navvy.Task)
}

func (o *CheckTasks) SetCheckTasks(v []func(t navvy.Task) navvy.Task) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type CheckTasksValidator interface {
	ValidateCheckTasks() bool
}

func (o *CheckTasks) ValidateCheckTasks() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadCheckTasks(t navvy.Task, v CheckTasksSetter) {
	x, ok := t.(interface {
		CheckTasksGetter
		CheckTasksValidator
	})
	if !ok {
		return
	}
	if !x.ValidateCheckTasks() {
		return
	}

	v.SetCheckTasks(x.GetCheckTasks())
}

func (o *CheckTasks) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type Content struct {
	valid bool
	v     *bytes.Buffer

	l sync.RWMutex
}

type ContentGetter interface {
	GetContent() *bytes.Buffer
}

func (o *Content) GetContent() *bytes.Buffer {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Content value is not valid")
	}
	return o.v
}

type ContentSetter interface {
	SetContent(*bytes.Buffer)
}

func (o *Content) SetContent(v *bytes.Buffer) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ContentValidator interface {
	ValidateContent() bool
}

func (o *Content) ValidateContent() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadContent(t navvy.Task, v ContentSetter) {
	x, ok := t.(interface {
		ContentGetter
		ContentValidator
	})
	if !ok {
		return
	}
	if !x.ValidateContent() {
		return
	}

	v.SetContent(x.GetContent())
}

func (o *Content) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type Delete struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type DeleteGetter interface {
	GetDelete() bool
}

func (o *Delete) GetDelete() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Delete value is not valid")
	}
	return o.v
}

type DeleteSetter interface {
	SetDelete(bool)
}

func (o *Delete) SetDelete(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type DeleteValidator interface {
	ValidateDelete() bool
}

func (o *Delete) ValidateDelete() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadDelete(t navvy.Task, v DeleteSetter) {
	x, ok := t.(interface {
		DeleteGetter
		DeleteValidator
	})
	if !ok {
		return
	}
	if !x.ValidateDelete() {
		return
	}

	v.SetDelete(x.GetDelete())
}

func (o *Delete) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatBool(o.v)
}

type DestinationIndexSegmenter struct {
	valid bool
	v     storage.IndexSegmenter

	l sync.RWMutex
}

type DestinationIndexSegmenterGetter interface {
	GetDestinationIndexSegmenter() storage.IndexSegmenter
}

func (o *DestinationIndexSegmenter) GetDestinationIndexSegmenter() storage.IndexSegmenter {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("DestinationIndexSegmenter value is not valid")
	}
	return o.v
}

type DestinationIndexSegmenterSetter interface {
	SetDestinationIndexSegmenter(storage.IndexSegmenter)
}

func (o *DestinationIndexSegmenter) SetDestinationIndexSegmenter(v storage.IndexSegmenter) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type DestinationIndexSegmenterValidator interface {
	ValidateDestinationIndexSegmenter() bool
}

func (o *DestinationIndexSegmenter) ValidateDestinationIndexSegmenter() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadDestinationIndexSegmenter(t navvy.Task, v DestinationIndexSegmenterSetter) {
	x, ok := t.(interface {
		DestinationIndexSegmenterGetter
		DestinationIndexSegmenterValidator
	})
	if !ok {
		return
	}
	if !x.ValidateDestinationIndexSegmenter() {
		return
	}

	v.SetDestinationIndexSegmenter(x.GetDestinationIndexSegmenter())
}

func (o *DestinationIndexSegmenter) String() string {
	if !o.valid {
		return ""
	}
	return o.v.(storage.Storager).String()
}

type DestinationObject struct {
	valid bool
	v     *types.Object

	l sync.RWMutex
}

type DestinationObjectGetter interface {
	GetDestinationObject() *types.Object
}

func (o *DestinationObject) GetDestinationObject() *types.Object {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("DestinationObject value is not valid")
	}
	return o.v
}

type DestinationObjectSetter interface {
	SetDestinationObject(*types.Object)
}

func (o *DestinationObject) SetDestinationObject(v *types.Object) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type DestinationObjectValidator interface {
	ValidateDestinationObject() bool
}

func (o *DestinationObject) ValidateDestinationObject() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadDestinationObject(t navvy.Task, v DestinationObjectSetter) {
	x, ok := t.(interface {
		DestinationObjectGetter
		DestinationObjectValidator
	})
	if !ok {
		return
	}
	if !x.ValidateDestinationObject() {
		return
	}

	v.SetDestinationObject(x.GetDestinationObject())
}

func (o *DestinationObject) String() string {
	if !o.valid {
		return ""
	}
	if o.v == nil {
		return ""
	}
	return fmt.Sprint(o.v)
}

type DestinationPath struct {
	valid bool
	v     string

	l sync.RWMutex
}

type DestinationPathGetter interface {
	GetDestinationPath() string
}

func (o *DestinationPath) GetDestinationPath() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("DestinationPath value is not valid")
	}
	return o.v
}

type DestinationPathSetter interface {
	SetDestinationPath(string)
}

func (o *DestinationPath) SetDestinationPath(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type DestinationPathValidator interface {
	ValidateDestinationPath() bool
}

func (o *DestinationPath) ValidateDestinationPath() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadDestinationPath(t navvy.Task, v DestinationPathSetter) {
	x, ok := t.(interface {
		DestinationPathGetter
		DestinationPathValidator
	})
	if !ok {
		return
	}
	if !x.ValidateDestinationPath() {
		return
	}

	v.SetDestinationPath(x.GetDestinationPath())
}

func (o *DestinationPath) String() string {
	if !o.valid {
		return ""
	}
	return o.v
}

type DestinationService struct {
	valid bool
	v     storage.Servicer

	l sync.RWMutex
}

type DestinationServiceGetter interface {
	GetDestinationService() storage.Servicer
}

func (o *DestinationService) GetDestinationService() storage.Servicer {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("DestinationService value is not valid")
	}
	return o.v
}

type DestinationServiceSetter interface {
	SetDestinationService(storage.Servicer)
}

func (o *DestinationService) SetDestinationService(v storage.Servicer) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type DestinationServiceValidator interface {
	ValidateDestinationService() bool
}

func (o *DestinationService) ValidateDestinationService() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadDestinationService(t navvy.Task, v DestinationServiceSetter) {
	x, ok := t.(interface {
		DestinationServiceGetter
		DestinationServiceValidator
	})
	if !ok {
		return
	}
	if !x.ValidateDestinationService() {
		return
	}

	v.SetDestinationService(x.GetDestinationService())
}

func (o *DestinationService) String() string {
	if !o.valid {
		return ""
	}
	return o.v.String()
}

type DestinationStorage struct {
	valid bool
	v     storage.Storager

	l sync.RWMutex
}

type DestinationStorageGetter interface {
	GetDestinationStorage() storage.Storager
}

func (o *DestinationStorage) GetDestinationStorage() storage.Storager {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("DestinationStorage value is not valid")
	}
	return o.v
}

type DestinationStorageSetter interface {
	SetDestinationStorage(storage.Storager)
}

func (o *DestinationStorage) SetDestinationStorage(v storage.Storager) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type DestinationStorageValidator interface {
	ValidateDestinationStorage() bool
}

func (o *DestinationStorage) ValidateDestinationStorage() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadDestinationStorage(t navvy.Task, v DestinationStorageSetter) {
	x, ok := t.(interface {
		DestinationStorageGetter
		DestinationStorageValidator
	})
	if !ok {
		return
	}
	if !x.ValidateDestinationStorage() {
		return
	}

	v.SetDestinationStorage(x.GetDestinationStorage())
}

func (o *DestinationStorage) String() string {
	if !o.valid {
		return ""
	}
	return o.v.String()
}

type DestinationType struct {
	valid bool
	v     types.ObjectType

	l sync.RWMutex
}

type DestinationTypeGetter interface {
	GetDestinationType() types.ObjectType
}

func (o *DestinationType) GetDestinationType() types.ObjectType {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("DestinationType value is not valid")
	}
	return o.v
}

type DestinationTypeSetter interface {
	SetDestinationType(types.ObjectType)
}

func (o *DestinationType) SetDestinationType(v types.ObjectType) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type DestinationTypeValidator interface {
	ValidateDestinationType() bool
}

func (o *DestinationType) ValidateDestinationType() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadDestinationType(t navvy.Task, v DestinationTypeSetter) {
	x, ok := t.(interface {
		DestinationTypeGetter
		DestinationTypeValidator
	})
	if !ok {
		return
	}
	if !x.ValidateDestinationType() {
		return
	}

	v.SetDestinationType(x.GetDestinationType())
}

func (o *DestinationType) String() string {
	if !o.valid {
		return ""
	}
	return string(o.v)
}

type DirFunc struct {
	valid bool
	v     func(*types.Object)

	l sync.RWMutex
}

type DirFuncGetter interface {
	GetDirFunc() func(*types.Object)
}

func (o *DirFunc) GetDirFunc() func(*types.Object) {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("DirFunc value is not valid")
	}
	return o.v
}

type DirFuncSetter interface {
	SetDirFunc(func(*types.Object))
}

func (o *DirFunc) SetDirFunc(v func(*types.Object)) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type DirFuncValidator interface {
	ValidateDirFunc() bool
}

func (o *DirFunc) ValidateDirFunc() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadDirFunc(t navvy.Task, v DirFuncSetter) {
	x, ok := t.(interface {
		DirFuncGetter
		DirFuncValidator
	})
	if !ok {
		return
	}
	if !x.ValidateDirFunc() {
		return
	}

	v.SetDirFunc(x.GetDirFunc())
}

func (o *DirFunc) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type DirLister struct {
	valid bool
	v     storage.DirLister

	l sync.RWMutex
}

type DirListerGetter interface {
	GetDirLister() storage.DirLister
}

func (o *DirLister) GetDirLister() storage.DirLister {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("DirLister value is not valid")
	}
	return o.v
}

type DirListerSetter interface {
	SetDirLister(storage.DirLister)
}

func (o *DirLister) SetDirLister(v storage.DirLister) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type DirListerValidator interface {
	ValidateDirLister() bool
}

func (o *DirLister) ValidateDirLister() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadDirLister(t navvy.Task, v DirListerSetter) {
	x, ok := t.(interface {
		DirListerGetter
		DirListerValidator
	})
	if !ok {
		return
	}
	if !x.ValidateDirLister() {
		return
	}

	v.SetDirLister(x.GetDirLister())
}

func (o *DirLister) String() string {
	if !o.valid {
		return ""
	}
	return o.v.(storage.Storager).String()
}

type Done struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type DoneGetter interface {
	GetDone() bool
}

func (o *Done) GetDone() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Done value is not valid")
	}
	return o.v
}

type DoneSetter interface {
	SetDone(bool)
}

func (o *Done) SetDone(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type DoneValidator interface {
	ValidateDone() bool
}

func (o *Done) ValidateDone() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadDone(t navvy.Task, v DoneSetter) {
	x, ok := t.(interface {
		DoneGetter
		DoneValidator
	})
	if !ok {
		return
	}
	if !x.ValidateDone() {
		return
	}

	v.SetDone(x.GetDone())
}

func (o *Done) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatBool(o.v)
}

type DryRun struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type DryRunGetter interface {
	GetDryRun() bool
}

func (o *DryRun) GetDryRun() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("DryRun value is not valid")
	}
	return o.v
}

type DryRunSetter interface {
	SetDryRun(bool)
}

func (o *DryRun) SetDryRun(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type DryRunValidator interface {
	ValidateDryRun() bool
}

func (o *DryRun) ValidateDryRun() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadDryRun(t navvy.Task, v DryRunSetter) {
	x, ok := t.(interface {
		DryRunGetter
		DryRunValidator
	})
	if !ok {
		return
	}
	if !x.ValidateDryRun() {
		return
	}

	v.SetDryRun(x.GetDryRun())
}

func (o *DryRun) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatBool(o.v)
}

type DryRunFunc struct {
	valid bool
	v     func(*types.Object)

	l sync.RWMutex
}

type DryRunFuncGetter interface {
	GetDryRunFunc() func(*types.Object)
}

func (o *DryRunFunc) GetDryRunFunc() func(*types.Object) {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("DryRunFunc value is not valid")
	}
	return o.v
}

type DryRunFuncSetter interface {
	SetDryRunFunc(func(*types.Object))
}

func (o *DryRunFunc) SetDryRunFunc(v func(*types.Object)) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type DryRunFuncValidator interface {
	ValidateDryRunFunc() bool
}

func (o *DryRunFunc) ValidateDryRunFunc() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadDryRunFunc(t navvy.Task, v DryRunFuncSetter) {
	x, ok := t.(interface {
		DryRunFuncGetter
		DryRunFuncValidator
	})
	if !ok {
		return
	}
	if !x.ValidateDryRunFunc() {
		return
	}

	v.SetDryRunFunc(x.GetDryRunFunc())
}

func (o *DryRunFunc) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type EnableBenchmark struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type EnableBenchmarkGetter interface {
	GetEnableBenchmark() bool
}

func (o *EnableBenchmark) GetEnableBenchmark() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("EnableBenchmark value is not valid")
	}
	return o.v
}

type EnableBenchmarkSetter interface {
	SetEnableBenchmark(bool)
}

func (o *EnableBenchmark) SetEnableBenchmark(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type EnableBenchmarkValidator interface {
	ValidateEnableBenchmark() bool
}

func (o *EnableBenchmark) ValidateEnableBenchmark() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadEnableBenchmark(t navvy.Task, v EnableBenchmarkSetter) {
	x, ok := t.(interface {
		EnableBenchmarkGetter
		EnableBenchmarkValidator
	})
	if !ok {
		return
	}
	if !x.ValidateEnableBenchmark() {
		return
	}

	v.SetEnableBenchmark(x.GetEnableBenchmark())
}

func (o *EnableBenchmark) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatBool(o.v)
}

type ExcludeRegexp struct {
	valid bool
	v     *regexp.Regexp

	l sync.RWMutex
}

type ExcludeRegexpGetter interface {
	GetExcludeRegexp() *regexp.Regexp
}

func (o *ExcludeRegexp) GetExcludeRegexp() *regexp.Regexp {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("ExcludeRegexp value is not valid")
	}
	return o.v
}

type ExcludeRegexpSetter interface {
	SetExcludeRegexp(*regexp.Regexp)
}

func (o *ExcludeRegexp) SetExcludeRegexp(v *regexp.Regexp) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ExcludeRegexpValidator interface {
	ValidateExcludeRegexp() bool
}

func (o *ExcludeRegexp) ValidateExcludeRegexp() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadExcludeRegexp(t navvy.Task, v ExcludeRegexpSetter) {
	x, ok := t.(interface {
		ExcludeRegexpGetter
		ExcludeRegexpValidator
	})
	if !ok {
		return
	}
	if !x.ValidateExcludeRegexp() {
		return
	}

	v.SetExcludeRegexp(x.GetExcludeRegexp())
}

func (o *ExcludeRegexp) String() string {
	if !o.valid {
		return ""
	}
	if o.v == nil {
		return ""
	}
	return o.v.String()
}

type Existing struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type ExistingGetter interface {
	GetExisting() bool
}

func (o *Existing) GetExisting() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Existing value is not valid")
	}
	return o.v
}

type ExistingSetter interface {
	SetExisting(bool)
}

func (o *Existing) SetExisting(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ExistingValidator interface {
	ValidateExisting() bool
}

func (o *Existing) ValidateExisting() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadExisting(t navvy.Task, v ExistingSetter) {
	x, ok := t.(interface {
		ExistingGetter
		ExistingValidator
	})
	if !ok {
		return
	}
	if !x.ValidateExisting() {
		return
	}

	v.SetExisting(x.GetExisting())
}

func (o *Existing) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatBool(o.v)
}

type ExpectSize struct {
	valid bool
	v     int64

	l sync.RWMutex
}

type ExpectSizeGetter interface {
	GetExpectSize() int64
}

func (o *ExpectSize) GetExpectSize() int64 {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("ExpectSize value is not valid")
	}
	return o.v
}

type ExpectSizeSetter interface {
	SetExpectSize(int64)
}

func (o *ExpectSize) SetExpectSize(v int64) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ExpectSizeValidator interface {
	ValidateExpectSize() bool
}

func (o *ExpectSize) ValidateExpectSize() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadExpectSize(t navvy.Task, v ExpectSizeSetter) {
	x, ok := t.(interface {
		ExpectSizeGetter
		ExpectSizeValidator
	})
	if !ok {
		return
	}
	if !x.ValidateExpectSize() {
		return
	}

	v.SetExpectSize(x.GetExpectSize())
}

func (o *ExpectSize) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatInt(o.v, 10)
}

type Expire struct {
	valid bool
	v     int

	l sync.RWMutex
}

type ExpireGetter interface {
	GetExpire() int
}

func (o *Expire) GetExpire() int {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Expire value is not valid")
	}
	return o.v
}

type ExpireSetter interface {
	SetExpire(int)
}

func (o *Expire) SetExpire(v int) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ExpireValidator interface {
	ValidateExpire() bool
}

func (o *Expire) ValidateExpire() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadExpire(t navvy.Task, v ExpireSetter) {
	x, ok := t.(interface {
		ExpireGetter
		ExpireValidator
	})
	if !ok {
		return
	}
	if !x.ValidateExpire() {
		return
	}

	v.SetExpire(x.GetExpire())
}

func (o *Expire) String() string {
	if !o.valid {
		return ""
	}
	return strconv.Itoa(o.v)
}

type Fault struct {
	valid bool
	v     *fault.Fault

	l sync.RWMutex
}

type FaultGetter interface {
	GetFault() *fault.Fault
}

func (o *Fault) GetFault() *fault.Fault {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Fault value is not valid")
	}
	return o.v
}

type FaultSetter interface {
	SetFault(*fault.Fault)
}

func (o *Fault) SetFault(v *fault.Fault) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type FaultValidator interface {
	ValidateFault() bool
}

func (o *Fault) ValidateFault() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadFault(t navvy.Task, v FaultSetter) {
	x, ok := t.(interface {
		FaultGetter
		FaultValidator
	})
	if !ok {
		return
	}
	if !x.ValidateFault() {
		return
	}

	v.SetFault(x.GetFault())
}

func (o *Fault) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type FileFunc struct {
	valid bool
	v     func(*types.Object)

	l sync.RWMutex
}

type FileFuncGetter interface {
	GetFileFunc() func(*types.Object)
}

func (o *FileFunc) GetFileFunc() func(*types.Object) {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("FileFunc value is not valid")
	}
	return o.v
}

type FileFuncSetter interface {
	SetFileFunc(func(*types.Object))
}

func (o *FileFunc) SetFileFunc(v func(*types.Object)) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type FileFuncValidator interface {
	ValidateFileFunc() bool
}

func (o *FileFunc) ValidateFileFunc() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadFileFunc(t navvy.Task, v FileFuncSetter) {
	x, ok := t.(interface {
		FileFuncGetter
		FileFuncValidator
	})
	if !ok {
		return
	}
	if !x.ValidateFileFunc() {
		return
	}

	v.SetFileFunc(x.GetFileFunc())
}

func (o *FileFunc) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type Force struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type ForceGetter interface {
	GetForce() bool
}

func (o *Force) GetForce() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Force value is not valid")
	}
	return o.v
}

type ForceSetter interface {
	SetForce(bool)
}

func (o *Force) SetForce(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ForceValidator interface {
	ValidateForce() bool
}

func (o *Force) ValidateForce() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadForce(t navvy.Task, v ForceSetter) {
	x, ok := t.(interface {
		ForceGetter
		ForceValidator
	})
	if !ok {
		return
	}
	if !x.ValidateForce() {
		return
	}

	v.SetForce(x.GetForce())
}

func (o *Force) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatBool(o.v)
}

type HandleObjCallback struct {
	valid bool
	v     func(*types.Object)

	l sync.RWMutex
}

type HandleObjCallbackGetter interface {
	GetHandleObjCallback() func(*types.Object)
}

func (o *HandleObjCallback) GetHandleObjCallback() func(*types.Object) {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("HandleObjCallback value is not valid")
	}
	return o.v
}

type HandleObjCallbackSetter interface {
	SetHandleObjCallback(func(*types.Object))
}

func (o *HandleObjCallback) SetHandleObjCallback(v func(*types.Object)) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type HandleObjCallbackValidator interface {
	ValidateHandleObjCallback() bool
}

func (o *HandleObjCallback) ValidateHandleObjCallback() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadHandleObjCallback(t navvy.Task, v HandleObjCallbackSetter) {
	x, ok := t.(interface {
		HandleObjCallbackGetter
		HandleObjCallbackValidator
	})
	if !ok {
		return
	}
	if !x.ValidateHandleObjCallback() {
		return
	}

	v.SetHandleObjCallback(x.GetHandleObjCallback())
}

func (o *HandleObjCallback) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type HandleSegmentCallback struct {
	valid bool
	v     func(segment.Segment)

	l sync.RWMutex
}

type HandleSegmentCallbackGetter interface {
	GetHandleSegmentCallback() func(segment.Segment)
}

func (o *HandleSegmentCallback) GetHandleSegmentCallback() func(segment.Segment) {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("HandleSegmentCallback value is not valid")
	}
	return o.v
}

type HandleSegmentCallbackSetter interface {
	SetHandleSegmentCallback(func(segment.Segment))
}

func (o *HandleSegmentCallback) SetHandleSegmentCallback(v func(segment.Segment)) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type HandleSegmentCallbackValidator interface {
	ValidateHandleSegmentCallback() bool
}

func (o *HandleSegmentCallback) ValidateHandleSegmentCallback() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadHandleSegmentCallback(t navvy.Task, v HandleSegmentCallbackSetter) {
	x, ok := t.(interface {
		HandleSegmentCallbackGetter
		HandleSegmentCallbackValidator
	})
	if !ok {
		return
	}
	if !x.ValidateHandleSegmentCallback() {
		return
	}

	v.SetHandleSegmentCallback(x.GetHandleSegmentCallback())
}

func (o *HandleSegmentCallback) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type HumanReadable struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type HumanReadableGetter interface {
	GetHumanReadable() bool
}

func (o *HumanReadable) GetHumanReadable() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("HumanReadable value is not valid")
	}
	return o.v
}

type HumanReadableSetter interface {
	SetHumanReadable(bool)
}

func (o *HumanReadable) SetHumanReadable(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type HumanReadableValidator interface {
	ValidateHumanReadable() bool
}

func (o *HumanReadable) ValidateHumanReadable() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadHumanReadable(t navvy.Task, v HumanReadableSetter) {
	x, ok := t.(interface {
		HumanReadableGetter
		HumanReadableValidator
	})
	if !ok {
		return
	}
	if !x.ValidateHumanReadable() {
		return
	}

	v.SetHumanReadable(x.GetHumanReadable())
}

func (o *HumanReadable) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatBool(o.v)
}

type ID struct {
	valid bool
	v     string

	l sync.RWMutex
}

type IDGetter interface {
	GetID() string
}

func (o *ID) GetID() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("ID value is not valid")
	}
	return o.v
}

type IDSetter interface {
	SetID(string)
}

func (o *ID) SetID(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type IDValidator interface {
	ValidateID() bool
}

func (o *ID) ValidateID() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadID(t navvy.Task, v IDSetter) {
	x, ok := t.(interface {
		IDGetter
		IDValidator
	})
	if !ok {
		return
	}
	if !x.ValidateID() {
		return
	}

	v.SetID(x.GetID())
}

func (o *ID) String() string {
	if !o.valid {
		return ""
	}
	return o.v
}

type IgnoreExisting struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type IgnoreExistingGetter interface {
	GetIgnoreExisting() bool
}

func (o *IgnoreExisting) GetIgnoreExisting() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("IgnoreExisting value is not valid")
	}
	return o.v
}

type IgnoreExistingSetter interface {
	SetIgnoreExisting(bool)
}

func (o *IgnoreExisting) SetIgnoreExisting(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type IgnoreExistingValidator interface {
	ValidateIgnoreExisting() bool
}

func (o *IgnoreExisting) ValidateIgnoreExisting() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadIgnoreExisting(t navvy.Task, v IgnoreExistingSetter) {
	x, ok := t.(interface {
		IgnoreExistingGetter
		IgnoreExistingValidator
	})
	if !ok {
		return
	}
	if !x.ValidateIgnoreExisting() {
		return
	}

	v.SetIgnoreExisting(x.GetIgnoreExisting())
}

func (o *IgnoreExisting) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatBool(o.v)
}

type IncludeRegexp struct {
	valid bool
	v     *regexp.Regexp

	l sync.RWMutex
}

type IncludeRegexpGetter interface {
	GetIncludeRegexp() *regexp.Regexp
}

func (o *IncludeRegexp) GetIncludeRegexp() *regexp.Regexp {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("IncludeRegexp value is not valid")
	}
	return o.v
}

type IncludeRegexpSetter interface {
	SetIncludeRegexp(*regexp.Regexp)
}

func (o *IncludeRegexp) SetIncludeRegexp(v *regexp.Regexp) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type IncludeRegexpValidator interface {
	ValidateIncludeRegexp() bool
}

func (o *IncludeRegexp) ValidateIncludeRegexp() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadIncludeRegexp(t navvy.Task, v IncludeRegexpSetter) {
	x, ok := t.(interface {
		IncludeRegexpGetter
		IncludeRegexpValidator
	})
	if !ok {
		return
	}
	if !x.ValidateIncludeRegexp() {
		return
	}

	v.SetIncludeRegexp(x.GetIncludeRegexp())
}

func (o *IncludeRegexp) String() string {
	if !o.valid {
		return ""
	}
	if o.v == nil {
		return ""
	}
	return o.v.String()
}

type Index struct {
	valid bool
	v     int

	l sync.RWMutex
}

type IndexGetter interface {
	GetIndex() int
}

func (o *Index) GetIndex() int {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Index value is not valid")
	}
	return o.v
}

type IndexSetter interface {
	SetIndex(int)
}

func (o *Index) SetIndex(v int) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type IndexValidator interface {
	ValidateIndex() bool
}

func (o *Index) ValidateIndex() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadIndex(t navvy.Task, v IndexSetter) {
	x, ok := t.(interface {
		IndexGetter
		IndexValidator
	})
	if !ok {
		return
	}
	if !x.ValidateIndex() {
		return
	}

	v.SetIndex(x.GetIndex())
}

func (o *Index) String() string {
	if !o.valid {
		return ""
	}
	return strconv.Itoa(o.v)
}

type IndexSegmenter struct {
	valid bool
	v     storage.IndexSegmenter

	l sync.RWMutex
}

type IndexSegmenterGetter interface {
	GetIndexSegmenter() storage.IndexSegmenter
}

func (o *IndexSegmenter) GetIndexSegmenter() storage.IndexSegmenter {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("IndexSegmenter value is not valid")
	}
	return o.v
}

type IndexSegmenterSetter interface {
	SetIndexSegmenter(storage.IndexSegmenter)
}

func (o *IndexSegmenter) SetIndexSegmenter(v storage.IndexSegmenter) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type IndexSegmenterValidator interface {
	ValidateIndexSegmenter() bool
}

func (o *IndexSegmenter) ValidateIndexSegmenter() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadIndexSegmenter(t navvy.Task, v IndexSegmenterSetter) {
	x, ok := t.(interface {
		IndexSegmenterGetter
		IndexSegmenterValidator
	})
	if !ok {
		return
	}
	if !x.ValidateIndexSegmenter() {
		return
	}

	v.SetIndexSegmenter(x.GetIndexSegmenter())
}

func (o *IndexSegmenter) String() string {
	if !o.valid {
		return ""
	}
	return o.v.(storage.Storager).String()
}

type LongFormat struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type LongFormatGetter interface {
	GetLongFormat() bool
}

func (o *LongFormat) GetLongFormat() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("LongFormat value is not valid")
	}
	return o.v
}

type LongFormatSetter interface {
	SetLongFormat(bool)
}

func (o *LongFormat) SetLongFormat(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type LongFormatValidator interface {
	ValidateLongFormat() bool
}

func (o *LongFormat) ValidateLongFormat() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadLongFormat(t navvy.Task, v LongFormatSetter) {
	x, ok := t.(interface {
		LongFormatGetter
		LongFormatValidator
	})
	if !ok {
		return
	}
	if !x.ValidateLongFormat() {
		return
	}

	v.SetLongFormat(x.GetLongFormat())
}

func (o *LongFormat) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatBool(o.v)
}

type MD5Sum struct {
	valid bool
	v     []byte

	l sync.RWMutex
}

type MD5SumGetter interface {
	GetMD5Sum() []byte
}

func (o *MD5Sum) GetMD5Sum() []byte {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("MD5Sum value is not valid")
	}
	return o.v
}

type MD5SumSetter interface {
	SetMD5Sum([]byte)
}

func (o *MD5Sum) SetMD5Sum(v []byte) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type MD5SumValidator interface {
	ValidateMD5Sum() bool
}

func (o *MD5Sum) ValidateMD5Sum() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadMD5Sum(t navvy.Task, v MD5SumSetter) {
	x, ok := t.(interface {
		MD5SumGetter
		MD5SumValidator
	})
	if !ok {
		return
	}
	if !x.ValidateMD5Sum() {
		return
	}

	v.SetMD5Sum(x.GetMD5Sum())
}

func (o *MD5Sum) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type Name struct {
	valid bool
	v     string

	l sync.RWMutex
}

type NameGetter interface {
	GetName() string
}

func (o *Name) GetName() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Name value is not valid")
	}
	return o.v
}

type NameSetter interface {
	SetName(string)
}

func (o *Name) SetName(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type NameValidator interface {
	ValidateName() bool
}

func (o *Name) ValidateName() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadName(t navvy.Task, v NameSetter) {
	x, ok := t.(interface {
		NameGetter
		NameValidator
	})
	if !ok {
		return
	}
	if !x.ValidateName() {
		return
	}

	v.SetName(x.GetName())
}

func (o *Name) String() string {
	if !o.valid {
		return ""
	}
	return o.v
}

type Object struct {
	valid bool
	v     *types.Object

	l sync.RWMutex
}

type ObjectGetter interface {
	GetObject() *types.Object
}

func (o *Object) GetObject() *types.Object {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Object value is not valid")
	}
	return o.v
}

type ObjectSetter interface {
	SetObject(*types.Object)
}

func (o *Object) SetObject(v *types.Object) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ObjectValidator interface {
	ValidateObject() bool
}

func (o *Object) ValidateObject() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadObject(t navvy.Task, v ObjectSetter) {
	x, ok := t.(interface {
		ObjectGetter
		ObjectValidator
	})
	if !ok {
		return
	}
	if !x.ValidateObject() {
		return
	}

	v.SetObject(x.GetObject())
}

func (o *Object) String() string {
	if !o.valid {
		return ""
	}
	if o.v == nil {
		return ""
	}
	return fmt.Sprint(o.v)
}

type ObjectFunc struct {
	valid bool
	v     func(*types.Object)

	l sync.RWMutex
}

type ObjectFuncGetter interface {
	GetObjectFunc() func(*types.Object)
}

func (o *ObjectFunc) GetObjectFunc() func(*types.Object) {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("ObjectFunc value is not valid")
	}
	return o.v
}

type ObjectFuncSetter interface {
	SetObjectFunc(func(*types.Object))
}

func (o *ObjectFunc) SetObjectFunc(v func(*types.Object)) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ObjectFuncValidator interface {
	ValidateObjectFunc() bool
}

func (o *ObjectFunc) ValidateObjectFunc() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadObjectFunc(t navvy.Task, v ObjectFuncSetter) {
	x, ok := t.(interface {
		ObjectFuncGetter
		ObjectFuncValidator
	})
	if !ok {
		return
	}
	if !x.ValidateObjectFunc() {
		return
	}

	v.SetObjectFunc(x.GetObjectFunc())
}

func (o *ObjectFunc) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type Offset struct {
	valid bool
	v     int64

	l sync.RWMutex
}

type OffsetGetter interface {
	GetOffset() int64
}

func (o *Offset) GetOffset() int64 {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Offset value is not valid")
	}
	return o.v
}

type OffsetSetter interface {
	SetOffset(int64)
}

func (o *Offset) SetOffset(v int64) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type OffsetValidator interface {
	ValidateOffset() bool
}

func (o *Offset) ValidateOffset() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadOffset(t navvy.Task, v OffsetSetter) {
	x, ok := t.(interface {
		OffsetGetter
		OffsetValidator
	})
	if !ok {
		return
	}
	if !x.ValidateOffset() {
		return
	}

	v.SetOffset(x.GetOffset())
}

func (o *Offset) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatInt(o.v, 10)
}

type PartNumber struct {
	valid bool
	v     int

	l sync.RWMutex
}

type PartNumberGetter interface {
	GetPartNumber() int
}

func (o *PartNumber) GetPartNumber() int {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("PartNumber value is not valid")
	}
	return o.v
}

type PartNumberSetter interface {
	SetPartNumber(int)
}

func (o *PartNumber) SetPartNumber(v int) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type PartNumberValidator interface {
	ValidatePartNumber() bool
}

func (o *PartNumber) ValidatePartNumber() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadPartNumber(t navvy.Task, v PartNumberSetter) {
	x, ok := t.(interface {
		PartNumberGetter
		PartNumberValidator
	})
	if !ok {
		return
	}
	if !x.ValidatePartNumber() {
		return
	}

	v.SetPartNumber(x.GetPartNumber())
}

func (o *PartNumber) String() string {
	if !o.valid {
		return ""
	}
	return strconv.Itoa(o.v)
}

type PartSize struct {
	valid bool
	v     int64

	l sync.RWMutex
}

type PartSizeGetter interface {
	GetPartSize() int64
}

func (o *PartSize) GetPartSize() int64 {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("PartSize value is not valid")
	}
	return o.v
}

type PartSizeSetter interface {
	SetPartSize(int64)
}

func (o *PartSize) SetPartSize(v int64) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type PartSizeValidator interface {
	ValidatePartSize() bool
}

func (o *PartSize) ValidatePartSize() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadPartSize(t navvy.Task, v PartSizeSetter) {
	x, ok := t.(interface {
		PartSizeGetter
		PartSizeValidator
	})
	if !ok {
		return
	}
	if !x.ValidatePartSize() {
		return
	}

	v.SetPartSize(x.GetPartSize())
}

func (o *PartSize) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatInt(o.v, 10)
}

type PartThreshold struct {
	valid bool
	v     int64

	l sync.RWMutex
}

type PartThresholdGetter interface {
	GetPartThreshold() int64
}

func (o *PartThreshold) GetPartThreshold() int64 {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("PartThreshold value is not valid")
	}
	return o.v
}

type PartThresholdSetter interface {
	SetPartThreshold(int64)
}

func (o *PartThreshold) SetPartThreshold(v int64) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type PartThresholdValidator interface {
	ValidatePartThreshold() bool
}

func (o *PartThreshold) ValidatePartThreshold() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadPartThreshold(t navvy.Task, v PartThresholdSetter) {
	x, ok := t.(interface {
		PartThresholdGetter
		PartThresholdValidator
	})
	if !ok {
		return
	}
	if !x.ValidatePartThreshold() {
		return
	}

	v.SetPartThreshold(x.GetPartThreshold())
}

func (o *PartThreshold) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatInt(o.v, 10)
}

type Passed struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type PassedGetter interface {
	GetPassed() bool
}

func (o *Passed) GetPassed() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Passed value is not valid")
	}
	return o.v
}

type PassedSetter interface {
	SetPassed(bool)
}

func (o *Passed) SetPassed(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type PassedValidator interface {
	ValidatePassed() bool
}

func (o *Passed) ValidatePassed() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadPassed(t navvy.Task, v PassedSetter) {
	x, ok := t.(interface {
		PassedGetter
		PassedValidator
	})
	if !ok {
		return
	}
	if !x.ValidatePassed() {
		return
	}

	v.SetPassed(x.GetPassed())
}

func (o *Passed) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatBool(o.v)
}

type Path struct {
	valid bool
	v     string

	l sync.RWMutex
}

type PathGetter interface {
	GetPath() string
}

func (o *Path) GetPath() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Path value is not valid")
	}
	return o.v
}

type PathSetter interface {
	SetPath(string)
}

func (o *Path) SetPath(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type PathValidator interface {
	ValidatePath() bool
}

func (o *Path) ValidatePath() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadPath(t navvy.Task, v PathSetter) {
	x, ok := t.(interface {
		PathGetter
		PathValidator
	})
	if !ok {
		return
	}
	if !x.ValidatePath() {
		return
	}

	v.SetPath(x.GetPath())
}

func (o *Path) String() string {
	if !o.valid {
		return ""
	}
	return o.v
}

type Pool struct {
	valid bool
	v     *navvy.Pool

	l sync.RWMutex
}

type PoolGetter interface {
	GetPool() *navvy.Pool
}

func (o *Pool) GetPool() *navvy.Pool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Pool value is not valid")
	}
	return o.v
}

type PoolSetter interface {
	SetPool(*navvy.Pool)
}

func (o *Pool) SetPool(v *navvy.Pool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type PoolValidator interface {
	ValidatePool() bool
}

func (o *Pool) ValidatePool() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadPool(t navvy.Task, v PoolSetter) {
	x, ok := t.(interface {
		PoolGetter
		PoolValidator
	})
	if !ok {
		return
	}
	if !x.ValidatePool() {
		return
	}

	v.SetPool(x.GetPool())
}

func (o *Pool) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type PrefixLister struct {
	valid bool
	v     storage.PrefixLister

	l sync.RWMutex
}

type PrefixListerGetter interface {
	GetPrefixLister() storage.PrefixLister
}

func (o *PrefixLister) GetPrefixLister() storage.PrefixLister {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("PrefixLister value is not valid")
	}
	return o.v
}

type PrefixListerSetter interface {
	SetPrefixLister(storage.PrefixLister)
}

func (o *PrefixLister) SetPrefixLister(v storage.PrefixLister) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type PrefixListerValidator interface {
	ValidatePrefixLister() bool
}

func (o *PrefixLister) ValidatePrefixLister() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadPrefixLister(t navvy.Task, v PrefixListerSetter) {
	x, ok := t.(interface {
		PrefixListerGetter
		PrefixListerValidator
	})
	if !ok {
		return
	}
	if !x.ValidatePrefixLister() {
		return
	}

	v.SetPrefixLister(x.GetPrefixLister())
}

func (o *PrefixLister) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type PrefixSegmentsLister struct {
	valid bool
	v     storage.PrefixSegmentsLister

	l sync.RWMutex
}

type PrefixSegmentsListerGetter interface {
	GetPrefixSegmentsLister() storage.PrefixSegmentsLister
}

func (o *PrefixSegmentsLister) GetPrefixSegmentsLister() storage.PrefixSegmentsLister {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("PrefixSegmentsLister value is not valid")
	}
	return o.v
}

type PrefixSegmentsListerSetter interface {
	SetPrefixSegmentsLister(storage.PrefixSegmentsLister)
}

func (o *PrefixSegmentsLister) SetPrefixSegmentsLister(v storage.PrefixSegmentsLister) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type PrefixSegmentsListerValidator interface {
	ValidatePrefixSegmentsLister() bool
}

func (o *PrefixSegmentsLister) ValidatePrefixSegmentsLister() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadPrefixSegmentsLister(t navvy.Task, v PrefixSegmentsListerSetter) {
	x, ok := t.(interface {
		PrefixSegmentsListerGetter
		PrefixSegmentsListerValidator
	})
	if !ok {
		return
	}
	if !x.ValidatePrefixSegmentsLister() {
		return
	}

	v.SetPrefixSegmentsLister(x.GetPrefixSegmentsLister())
}

func (o *PrefixSegmentsLister) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type Reacher struct {
	valid bool
	v     storage.Reacher

	l sync.RWMutex
}

type ReacherGetter interface {
	GetReacher() storage.Reacher
}

func (o *Reacher) GetReacher() storage.Reacher {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Reacher value is not valid")
	}
	return o.v
}

type ReacherSetter interface {
	SetReacher(storage.Reacher)
}

func (o *Reacher) SetReacher(v storage.Reacher) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ReacherValidator interface {
	ValidateReacher() bool
}

func (o *Reacher) ValidateReacher() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadReacher(t navvy.Task, v ReacherSetter) {
	x, ok := t.(interface {
		ReacherGetter
		ReacherValidator
	})
	if !ok {
		return
	}
	if !x.ValidateReacher() {
		return
	}

	v.SetReacher(x.GetReacher())
}

func (o *Reacher) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type ReadableSize struct {
	valid bool
	v     string

	l sync.RWMutex
}

type ReadableSizeGetter interface {
	GetReadableSize() string
}

func (o *ReadableSize) GetReadableSize() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("ReadableSize value is not valid")
	}
	return o.v
}

type ReadableSizeSetter interface {
	SetReadableSize(string)
}

func (o *ReadableSize) SetReadableSize(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ReadableSizeValidator interface {
	ValidateReadableSize() bool
}

func (o *ReadableSize) ValidateReadableSize() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadReadableSize(t navvy.Task, v ReadableSizeSetter) {
	x, ok := t.(interface {
		ReadableSizeGetter
		ReadableSizeValidator
	})
	if !ok {
		return
	}
	if !x.ValidateReadableSize() {
		return
	}

	v.SetReadableSize(x.GetReadableSize())
}

func (o *ReadableSize) String() string {
	if !o.valid {
		return ""
	}
	return o.v
}

type Recursive struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type RecursiveGetter interface {
	GetRecursive() bool
}

func (o *Recursive) GetRecursive() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Recursive value is not valid")
	}
	return o.v
}

type RecursiveSetter interface {
	SetRecursive(bool)
}

func (o *Recursive) SetRecursive(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type RecursiveValidator interface {
	ValidateRecursive() bool
}

func (o *Recursive) ValidateRecursive() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadRecursive(t navvy.Task, v RecursiveSetter) {
	x, ok := t.(interface {
		RecursiveGetter
		RecursiveValidator
	})
	if !ok {
		return
	}
	if !x.ValidateRecursive() {
		return
	}

	v.SetRecursive(x.GetRecursive())
}

func (o *Recursive) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatBool(o.v)
}

type Result struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type ResultGetter interface {
	GetResult() bool
}

func (o *Result) GetResult() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Result value is not valid")
	}
	return o.v
}

type ResultSetter interface {
	SetResult(bool)
}

func (o *Result) SetResult(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ResultValidator interface {
	ValidateResult() bool
}

func (o *Result) ValidateResult() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadResult(t navvy.Task, v ResultSetter) {
	x, ok := t.(interface {
		ResultGetter
		ResultValidator
	})
	if !ok {
		return
	}
	if !x.ValidateResult() {
		return
	}

	v.SetResult(x.GetResult())
}

func (o *Result) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatBool(o.v)
}

type ScheduleFunc struct {
	valid bool
	v     schedule.TaskFunc

	l sync.RWMutex
}

type ScheduleFuncGetter interface {
	GetScheduleFunc() schedule.TaskFunc
}

func (o *ScheduleFunc) GetScheduleFunc() schedule.TaskFunc {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("ScheduleFunc value is not valid")
	}
	return o.v
}

type ScheduleFuncSetter interface {
	SetScheduleFunc(schedule.TaskFunc)
}

func (o *ScheduleFunc) SetScheduleFunc(v schedule.TaskFunc) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ScheduleFuncValidator interface {
	ValidateScheduleFunc() bool
}

func (o *ScheduleFunc) ValidateScheduleFunc() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadScheduleFunc(t navvy.Task, v ScheduleFuncSetter) {
	x, ok := t.(interface {
		ScheduleFuncGetter
		ScheduleFuncValidator
	})
	if !ok {
		return
	}
	if !x.ValidateScheduleFunc() {
		return
	}

	v.SetScheduleFunc(x.GetScheduleFunc())
}

func (o *ScheduleFunc) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type Scheduler struct {
	valid bool
	v     schedule.Scheduler

	l sync.RWMutex
}

type SchedulerGetter interface {
	GetScheduler() schedule.Scheduler
}

func (o *Scheduler) GetScheduler() schedule.Scheduler {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Scheduler value is not valid")
	}
	return o.v
}

type SchedulerSetter interface {
	SetScheduler(schedule.Scheduler)
}

func (o *Scheduler) SetScheduler(v schedule.Scheduler) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type SchedulerValidator interface {
	ValidateScheduler() bool
}

func (o *Scheduler) ValidateScheduler() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadScheduler(t navvy.Task, v SchedulerSetter) {
	x, ok := t.(interface {
		SchedulerGetter
		SchedulerValidator
	})
	if !ok {
		return
	}
	if !x.ValidateScheduler() {
		return
	}

	v.SetScheduler(x.GetScheduler())
}

func (o *Scheduler) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type Segment struct {
	valid bool
	v     segment.Segment

	l sync.RWMutex
}

type SegmentGetter interface {
	GetSegment() segment.Segment
}

func (o *Segment) GetSegment() segment.Segment {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Segment value is not valid")
	}
	return o.v
}

type SegmentSetter interface {
	SetSegment(segment.Segment)
}

func (o *Segment) SetSegment(v segment.Segment) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type SegmentValidator interface {
	ValidateSegment() bool
}

func (o *Segment) ValidateSegment() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadSegment(t navvy.Task, v SegmentSetter) {
	x, ok := t.(interface {
		SegmentGetter
		SegmentValidator
	})
	if !ok {
		return
	}
	if !x.ValidateSegment() {
		return
	}

	v.SetSegment(x.GetSegment())
}

func (o *Segment) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type SegmentFunc struct {
	valid bool
	v     func(segment.Segment)

	l sync.RWMutex
}

type SegmentFuncGetter interface {
	GetSegmentFunc() func(segment.Segment)
}

func (o *SegmentFunc) GetSegmentFunc() func(segment.Segment) {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("SegmentFunc value is not valid")
	}
	return o.v
}

type SegmentFuncSetter interface {
	SetSegmentFunc(func(segment.Segment))
}

func (o *SegmentFunc) SetSegmentFunc(v func(segment.Segment)) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type SegmentFuncValidator interface {
	ValidateSegmentFunc() bool
}

func (o *SegmentFunc) ValidateSegmentFunc() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadSegmentFunc(t navvy.Task, v SegmentFuncSetter) {
	x, ok := t.(interface {
		SegmentFuncGetter
		SegmentFuncValidator
	})
	if !ok {
		return
	}
	if !x.ValidateSegmentFunc() {
		return
	}

	v.SetSegmentFunc(x.GetSegmentFunc())
}

func (o *SegmentFunc) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type Service struct {
	valid bool
	v     storage.Servicer

	l sync.RWMutex
}

type ServiceGetter interface {
	GetService() storage.Servicer
}

func (o *Service) GetService() storage.Servicer {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Service value is not valid")
	}
	return o.v
}

type ServiceSetter interface {
	SetService(storage.Servicer)
}

func (o *Service) SetService(v storage.Servicer) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ServiceValidator interface {
	ValidateService() bool
}

func (o *Service) ValidateService() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadService(t navvy.Task, v ServiceSetter) {
	x, ok := t.(interface {
		ServiceGetter
		ServiceValidator
	})
	if !ok {
		return
	}
	if !x.ValidateService() {
		return
	}

	v.SetService(x.GetService())
}

func (o *Service) String() string {
	if !o.valid {
		return ""
	}
	return o.v.String()
}

type Size struct {
	valid bool
	v     int64

	l sync.RWMutex
}

type SizeGetter interface {
	GetSize() int64
}

func (o *Size) GetSize() int64 {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Size value is not valid")
	}
	return o.v
}

type SizeSetter interface {
	SetSize(int64)
}

func (o *Size) SetSize(v int64) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type SizeValidator interface {
	ValidateSize() bool
}

func (o *Size) ValidateSize() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadSize(t navvy.Task, v SizeSetter) {
	x, ok := t.(interface {
		SizeGetter
		SizeValidator
	})
	if !ok {
		return
	}
	if !x.ValidateSize() {
		return
	}

	v.SetSize(x.GetSize())
}

func (o *Size) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatInt(o.v, 10)
}

type SourceObject struct {
	valid bool
	v     *types.Object

	l sync.RWMutex
}

type SourceObjectGetter interface {
	GetSourceObject() *types.Object
}

func (o *SourceObject) GetSourceObject() *types.Object {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("SourceObject value is not valid")
	}
	return o.v
}

type SourceObjectSetter interface {
	SetSourceObject(*types.Object)
}

func (o *SourceObject) SetSourceObject(v *types.Object) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type SourceObjectValidator interface {
	ValidateSourceObject() bool
}

func (o *SourceObject) ValidateSourceObject() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadSourceObject(t navvy.Task, v SourceObjectSetter) {
	x, ok := t.(interface {
		SourceObjectGetter
		SourceObjectValidator
	})
	if !ok {
		return
	}
	if !x.ValidateSourceObject() {
		return
	}

	v.SetSourceObject(x.GetSourceObject())
}

func (o *SourceObject) String() string {
	if !o.valid {
		return ""
	}
	if o.v == nil {
		return ""
	}
	return fmt.Sprint(o.v)
}

type SourcePath struct {
	valid bool
	v     string

	l sync.RWMutex
}

type SourcePathGetter interface {
	GetSourcePath() string
}

func (o *SourcePath) GetSourcePath() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("SourcePath value is not valid")
	}
	return o.v
}

type SourcePathSetter interface {
	SetSourcePath(string)
}

func (o *SourcePath) SetSourcePath(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type SourcePathValidator interface {
	ValidateSourcePath() bool
}

func (o *SourcePath) ValidateSourcePath() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadSourcePath(t navvy.Task, v SourcePathSetter) {
	x, ok := t.(interface {
		SourcePathGetter
		SourcePathValidator
	})
	if !ok {
		return
	}
	if !x.ValidateSourcePath() {
		return
	}

	v.SetSourcePath(x.GetSourcePath())
}

func (o *SourcePath) String() string {
	if !o.valid {
		return ""
	}
	return o.v
}

type SourceService struct {
	valid bool
	v     storage.Servicer

	l sync.RWMutex
}

type SourceServiceGetter interface {
	GetSourceService() storage.Servicer
}

func (o *SourceService) GetSourceService() storage.Servicer {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("SourceService value is not valid")
	}
	return o.v
}

type SourceServiceSetter interface {
	SetSourceService(storage.Servicer)
}

func (o *SourceService) SetSourceService(v storage.Servicer) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type SourceServiceValidator interface {
	ValidateSourceService() bool
}

func (o *SourceService) ValidateSourceService() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadSourceService(t navvy.Task, v SourceServiceSetter) {
	x, ok := t.(interface {
		SourceServiceGetter
		SourceServiceValidator
	})
	if !ok {
		return
	}
	if !x.ValidateSourceService() {
		return
	}

	v.SetSourceService(x.GetSourceService())
}

func (o *SourceService) String() string {
	if !o.valid {
		return ""
	}
	return o.v.String()
}

type SourceStorage struct {
	valid bool
	v     storage.Storager

	l sync.RWMutex
}

type SourceStorageGetter interface {
	GetSourceStorage() storage.Storager
}

func (o *SourceStorage) GetSourceStorage() storage.Storager {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("SourceStorage value is not valid")
	}
	return o.v
}

type SourceStorageSetter interface {
	SetSourceStorage(storage.Storager)
}

func (o *SourceStorage) SetSourceStorage(v storage.Storager) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type SourceStorageValidator interface {
	ValidateSourceStorage() bool
}

func (o *SourceStorage) ValidateSourceStorage() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadSourceStorage(t navvy.Task, v SourceStorageSetter) {
	x, ok := t.(interface {
		SourceStorageGetter
		SourceStorageValidator
	})
	if !ok {
		return
	}
	if !x.ValidateSourceStorage() {
		return
	}

	v.SetSourceStorage(x.GetSourceStorage())
}

func (o *SourceStorage) String() string {
	if !o.valid {
		return ""
	}
	return o.v.String()
}

type SourceType struct {
	valid bool
	v     types.ObjectType

	l sync.RWMutex
}

type SourceTypeGetter interface {
	GetSourceType() types.ObjectType
}

func (o *SourceType) GetSourceType() types.ObjectType {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("SourceType value is not valid")
	}
	return o.v
}

type SourceTypeSetter interface {
	SetSourceType(types.ObjectType)
}

func (o *SourceType) SetSourceType(v types.ObjectType) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type SourceTypeValidator interface {
	ValidateSourceType() bool
}

func (o *SourceType) ValidateSourceType() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadSourceType(t navvy.Task, v SourceTypeSetter) {
	x, ok := t.(interface {
		SourceTypeGetter
		SourceTypeValidator
	})
	if !ok {
		return
	}
	if !x.ValidateSourceType() {
		return
	}

	v.SetSourceType(x.GetSourceType())
}

func (o *SourceType) String() string {
	if !o.valid {
		return ""
	}
	return string(o.v)
}

type Storage struct {
	valid bool
	v     storage.Storager

	l sync.RWMutex
}

type StorageGetter interface {
	GetStorage() storage.Storager
}

func (o *Storage) GetStorage() storage.Storager {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Storage value is not valid")
	}
	return o.v
}

type StorageSetter interface {
	SetStorage(storage.Storager)
}

func (o *Storage) SetStorage(v storage.Storager) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type StorageValidator interface {
	ValidateStorage() bool
}

func (o *Storage) ValidateStorage() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadStorage(t navvy.Task, v StorageSetter) {
	x, ok := t.(interface {
		StorageGetter
		StorageValidator
	})
	if !ok {
		return
	}
	if !x.ValidateStorage() {
		return
	}

	v.SetStorage(x.GetStorage())
}

func (o *Storage) String() string {
	if !o.valid {
		return ""
	}
	return o.v.String()
}

type StorageInfo struct {
	valid bool
	v     info.StorageStatistic

	l sync.RWMutex
}

type StorageInfoGetter interface {
	GetStorageInfo() info.StorageStatistic
}

func (o *StorageInfo) GetStorageInfo() info.StorageStatistic {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("StorageInfo value is not valid")
	}
	return o.v
}

type StorageInfoSetter interface {
	SetStorageInfo(info.StorageStatistic)
}

func (o *StorageInfo) SetStorageInfo(v info.StorageStatistic) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type StorageInfoValidator interface {
	ValidateStorageInfo() bool
}

func (o *StorageInfo) ValidateStorageInfo() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadStorageInfo(t navvy.Task, v StorageInfoSetter) {
	x, ok := t.(interface {
		StorageInfoGetter
		StorageInfoValidator
	})
	if !ok {
		return
	}
	if !x.ValidateStorageInfo() {
		return
	}

	v.SetStorageInfo(x.GetStorageInfo())
}

func (o *StorageInfo) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type StorageName struct {
	valid bool
	v     string

	l sync.RWMutex
}

type StorageNameGetter interface {
	GetStorageName() string
}

func (o *StorageName) GetStorageName() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("StorageName value is not valid")
	}
	return o.v
}

type StorageNameSetter interface {
	SetStorageName(string)
}

func (o *StorageName) SetStorageName(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type StorageNameValidator interface {
	ValidateStorageName() bool
}

func (o *StorageName) ValidateStorageName() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadStorageName(t navvy.Task, v StorageNameSetter) {
	x, ok := t.(interface {
		StorageNameGetter
		StorageNameValidator
	})
	if !ok {
		return
	}
	if !x.ValidateStorageName() {
		return
	}

	v.SetStorageName(x.GetStorageName())
}

func (o *StorageName) String() string {
	if !o.valid {
		return ""
	}
	return o.v
}

type StoragerFunc struct {
	valid bool
	v     storage.StoragerFunc

	l sync.RWMutex
}

type StoragerFuncGetter interface {
	GetStoragerFunc() storage.StoragerFunc
}

func (o *StoragerFunc) GetStoragerFunc() storage.StoragerFunc {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("StoragerFunc value is not valid")
	}
	return o.v
}

type StoragerFuncSetter interface {
	SetStoragerFunc(storage.StoragerFunc)
}

func (o *StoragerFunc) SetStoragerFunc(v storage.StoragerFunc) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type StoragerFuncValidator interface {
	ValidateStoragerFunc() bool
}

func (o *StoragerFunc) ValidateStoragerFunc() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadStoragerFunc(t navvy.Task, v StoragerFuncSetter) {
	x, ok := t.(interface {
		StoragerFuncGetter
		StoragerFuncValidator
	})
	if !ok {
		return
	}
	if !x.ValidateStoragerFunc() {
		return
	}

	v.SetStoragerFunc(x.GetStoragerFunc())
}

func (o *StoragerFunc) String() string {
	if !o.valid {
		return ""
	}
	return ""
}

type TotalSize struct {
	valid bool
	v     int64

	l sync.RWMutex
}

type TotalSizeGetter interface {
	GetTotalSize() int64
}

func (o *TotalSize) GetTotalSize() int64 {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("TotalSize value is not valid")
	}
	return o.v
}

type TotalSizeSetter interface {
	SetTotalSize(int64)
}

func (o *TotalSize) SetTotalSize(v int64) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type TotalSizeValidator interface {
	ValidateTotalSize() bool
}

func (o *TotalSize) ValidateTotalSize() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadTotalSize(t navvy.Task, v TotalSizeSetter) {
	x, ok := t.(interface {
		TotalSizeGetter
		TotalSizeValidator
	})
	if !ok {
		return
	}
	if !x.ValidateTotalSize() {
		return
	}

	v.SetTotalSize(x.GetTotalSize())
}

func (o *TotalSize) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatInt(o.v, 10)
}

type Type struct {
	valid bool
	v     types.ObjectType

	l sync.RWMutex
}

type TypeGetter interface {
	GetType() types.ObjectType
}

func (o *Type) GetType() types.ObjectType {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Type value is not valid")
	}
	return o.v
}

type TypeSetter interface {
	SetType(types.ObjectType)
}

func (o *Type) SetType(v types.ObjectType) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type TypeValidator interface {
	ValidateType() bool
}

func (o *Type) ValidateType() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadType(t navvy.Task, v TypeSetter) {
	x, ok := t.(interface {
		TypeGetter
		TypeValidator
	})
	if !ok {
		return
	}
	if !x.ValidateType() {
		return
	}

	v.SetType(x.GetType())
}

func (o *Type) String() string {
	if !o.valid {
		return ""
	}
	return string(o.v)
}

type URL struct {
	valid bool
	v     string

	l sync.RWMutex
}

type URLGetter interface {
	GetURL() string
}

func (o *URL) GetURL() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("URL value is not valid")
	}
	return o.v
}

type URLSetter interface {
	SetURL(string)
}

func (o *URL) SetURL(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type URLValidator interface {
	ValidateURL() bool
}

func (o *URL) ValidateURL() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadURL(t navvy.Task, v URLSetter) {
	x, ok := t.(interface {
		URLGetter
		URLValidator
	})
	if !ok {
		return
	}
	if !x.ValidateURL() {
		return
	}

	v.SetURL(x.GetURL())
}

func (o *URL) String() string {
	if !o.valid {
		return ""
	}
	return o.v
}

type Update struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type UpdateGetter interface {
	GetUpdate() bool
}

func (o *Update) GetUpdate() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Update value is not valid")
	}
	return o.v
}

type UpdateSetter interface {
	SetUpdate(bool)
}

func (o *Update) SetUpdate(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type UpdateValidator interface {
	ValidateUpdate() bool
}

func (o *Update) ValidateUpdate() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadUpdate(t navvy.Task, v UpdateSetter) {
	x, ok := t.(interface {
		UpdateGetter
		UpdateValidator
	})
	if !ok {
		return
	}
	if !x.ValidateUpdate() {
		return
	}

	v.SetUpdate(x.GetUpdate())
}

func (o *Update) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatBool(o.v)
}

type WholeFile struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type WholeFileGetter interface {
	GetWholeFile() bool
}

func (o *WholeFile) GetWholeFile() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("WholeFile value is not valid")
	}
	return o.v
}

type WholeFileSetter interface {
	SetWholeFile(bool)
}

func (o *WholeFile) SetWholeFile(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type WholeFileValidator interface {
	ValidateWholeFile() bool
}

func (o *WholeFile) ValidateWholeFile() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadWholeFile(t navvy.Task, v WholeFileSetter) {
	x, ok := t.(interface {
		WholeFileGetter
		WholeFileValidator
	})
	if !ok {
		return
	}
	if !x.ValidateWholeFile() {
		return
	}

	v.SetWholeFile(x.GetWholeFile())
}

func (o *WholeFile) String() string {
	if !o.valid {
		return ""
	}
	return strconv.FormatBool(o.v)
}

type Zone struct {
	valid bool
	v     string

	l sync.RWMutex
}

type ZoneGetter interface {
	GetZone() string
}

func (o *Zone) GetZone() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Zone value is not valid")
	}
	return o.v
}

type ZoneSetter interface {
	SetZone(string)
}

func (o *Zone) SetZone(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ZoneValidator interface {
	ValidateZone() bool
}

func (o *Zone) ValidateZone() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadZone(t navvy.Task, v ZoneSetter) {
	x, ok := t.(interface {
		ZoneGetter
		ZoneValidator
	})
	if !ok {
		return
	}
	if !x.ValidateZone() {
		return
	}

	v.SetZone(x.GetZone())
}

func (o *Zone) String() string {
	if !o.valid {
		return ""
	}
	return o.v
}
